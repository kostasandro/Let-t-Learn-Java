-- phpMyAdmin SQL Dump
-- version 4.9.2
-- https://www.phpmyadmin.net/
--
-- Host: 127.0.0.1:3306
-- Generation Time: Jun 17, 2020 at 06:19 PM
-- Server version: 10.4.10-MariaDB
-- PHP Version: 7.3.12

SET SQL_MODE = "NO_AUTO_VALUE_ON_ZERO";
SET AUTOCOMMIT = 0;
START TRANSACTION;
SET time_zone = "+00:00";


/*!40101 SET @OLD_CHARACTER_SET_CLIENT=@@CHARACTER_SET_CLIENT */;
/*!40101 SET @OLD_CHARACTER_SET_RESULTS=@@CHARACTER_SET_RESULTS */;
/*!40101 SET @OLD_COLLATION_CONNECTION=@@COLLATION_CONNECTION */;
/*!40101 SET NAMES utf8mb4 */;

--
-- Database: `learnjava`
--

-- --------------------------------------------------------

--
-- Table structure for table `answer`
--

DROP TABLE IF EXISTS `answer`;
CREATE TABLE IF NOT EXISTS `answer` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `description` varchar(1500) COLLATE utf8_bin NOT NULL,
  `ordering` int(11) NOT NULL,
  `points` int(11) NOT NULL,
  `question_id` int(11) NOT NULL,
  PRIMARY KEY (`id`),
  KEY `question_id` (`question_id`)
) ENGINE=MyISAM AUTO_INCREMENT=117 DEFAULT CHARSET=utf8 COLLATE=utf8_bin;

--
-- Dumping data for table `answer`
--

INSERT INTO `answer` (`id`, `description`, `ordering`, `points`, `question_id`) VALUES
(1, 'Ειδική σελίδα στο internet', 1, 0, 1),
(2, 'Ένα από τα λειτουργικά συστήματα των Windows', 2, 0, 1),
(3, 'Ένα πρόγραμμα πλοήγησης στο internet ή μια εφαρμογή κατάλληλη για την εκτέλεση applet', 3, 10, 1),
(4, 'Σωστό', 1, 0, 2),
(5, 'Λάθος', 2, 10, 2),
(6, 'κεφαλαία', 1, 2, 3),
(7, 'διαφορετικά', 2, 6, 3),
(8, 'μικρά', 3, 2, 3),
(32, 'System.out.println(\"Hello World!!! I am Kostas\");', 1, 0, 15),
(22, 'Σωστό', 1, 0, 10),
(23, 'Λάθος', 2, 10, 10),
(52, 'switch', 2, 2, 23),
(51, 'if', 1, 2, 23),
(26, 'Σωστό', 1, 0, 12),
(27, 'Λάθος', 2, 10, 12),
(77, 'this', 2, 0, 31),
(76, 'break', 1, 0, 31),
(94, 'throwable', 1, 10, 14),
(31, 'Έναν συντάκτη κειμένου', 4, 0, 1),
(33, 'System.out.println(\"Hello World!!!\");\r\nSystem.out.println(\"I am Kostas\");', 2, 5, 15),
(34, 'System.out.println(\"Hello World!!! \\nI am Kostas\");\r\n\r\n\r\n', 3, 5, 15),
(35, 'γράμμα', 1, 3, 16),
(36, '$', 2, 3, 16),
(37, '_', 3, 4, 16),
(38, '//', 1, 5, 17),
(39, '**', 2, 0, 17),
(40, '/*', 3, 5, 17),
(41, '101', 1, 10, 18),
(42, 'Σωστό', 1, 0, 19),
(43, 'Λάθος', 2, 10, 19),
(44, 'a = 11\r\nb = 12\r\nx = 21', 1, 10, 20),
(45, 'a = 11\r\nb = 12\r\nx = 23', 2, 0, 20),
(46, 'a = 10\r\nb = 11\r\nx = 23', 3, 0, 20),
(47, 'Σωστό', 1, 10, 21),
(48, 'Λάθος', 2, 0, 21),
(49, 'Σωστό', 1, 10, 22),
(50, 'Λάθος', 2, 0, 22),
(53, 'for', 3, 2, 23),
(54, 'while', 4, 2, 23),
(55, 'do_while', 5, 2, 23),
(56, 'Σωστό', 1, 10, 24),
(57, 'Λάθος', 2, 0, 24),
(58, '1, 2, 4, 8, 16, 34, 64', 1, 0, 25),
(59, '1, 3, 5, 7, 9, 11, 13', 2, 0, 25),
(60, '1, 2, 4, 8, 16, 32, 64', 3, 10, 25),
(61, 'continue', 1, 0, 26),
(62, 'break', 2, 10, 26),
(63, 'exit', 3, 0, 26),
(64, 'goto', 4, 0, 26),
(65, 'continue', 1, 10, 27),
(66, 'break', 2, 0, 27),
(67, 'exit', 3, 0, 27),
(68, 'goto', 4, 0, 27),
(69, 'Σωστό', 1, 0, 28),
(70, 'Λάθος', 2, 10, 28),
(71, '3', 1, 0, 29),
(72, '7', 2, 0, 29),
(73, '1', 3, 10, 29),
(74, 'Σωστό', 1, 10, 30),
(75, 'Λάθος', 2, 0, 30),
(78, 'return', 3, 10, 31),
(79, 'pass', 4, 0, 31),
(80, 'Σωστό', 1, 10, 32),
(81, 'Λάθος', 2, 0, 32),
(82, 'Σωστό', 1, 10, 33),
(83, 'Λάθος', 2, 0, 33),
(84, 'ενθυλάκωση', 1, 0, 34),
(85, 'πολυμορφισμός', 2, 10, 34),
(86, 'κληρονομικότητα', 3, 0, 34),
(87, 'Σωστό', 1, 0, 35),
(88, 'Λάθος', 2, 10, 35),
(89, 'final', 1, 10, 36),
(90, 'interface', 1, 0, 37),
(91, 'implements', 2, 5, 37),
(92, 'abstract', 3, 5, 37),
(93, 'extends', 4, 0, 37),
(95, 'thread', 2, 0, 14),
(96, 'runnable', 3, 0, 14),
(97, 'Σωστό', 1, 0, 38),
(98, 'Λάθος', 2, 10, 38),
(99, 'Σωστό', 1, 0, 39),
(100, 'Λάθος', 2, 10, 39),
(101, 'Σωστό', 1, 0, 40),
(102, 'Λάθος', 2, 10, 40),
(103, 'ArithmeticException', 1, 0, 41),
(104, 'NumberFormatException', 2, 0, 41),
(105, 'OutOfMemoryException', 3, 0, 41),
(106, 'Δεν θα δημιουργηθεί εξαίρεση', 4, 10, 41),
(107, 'Σωστό', 1, 10, 42),
(108, 'Λάθος', 2, 0, 42),
(109, 'Σωστό', 1, 0, 43),
(110, 'Λάθος', 2, 10, 43),
(111, 'Σωστό', 1, 0, 44),
(112, 'Λάθος', 2, 10, 44),
(113, 'Σωστό', 1, 10, 45),
(114, 'Λάθος', 2, 0, 45),
(115, 'Σωστό', 1, 10, 46),
(116, 'Λάθος', 2, 0, 46);

-- --------------------------------------------------------

--
-- Table structure for table `exercise`
--

DROP TABLE IF EXISTS `exercise`;
CREATE TABLE IF NOT EXISTS `exercise` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `title` varchar(50) COLLATE utf8_bin NOT NULL,
  `ordering` int(11) NOT NULL,
  `description` longtext COLLATE utf8_bin NOT NULL,
  `solution` longtext COLLATE utf8_bin NOT NULL,
  `level_id` int(11) NOT NULL,
  PRIMARY KEY (`id`),
  KEY `level_id` (`level_id`)
) ENGINE=MyISAM AUTO_INCREMENT=37 DEFAULT CHARSET=utf8 COLLATE=utf8_bin;

--
-- Dumping data for table `exercise`
--

INSERT INTO `exercise` (`id`, `title`, `ordering`, `description`, `solution`, `level_id`) VALUES
(1, 'Hello World', 1, '<p>\r\n    Παρακάτω θα δημιουργήσουμε μια εφαρμογή σε Java, το “Hello World”, η οποία θα τρέχει αυτόματα χωρίς να κάνει χρήση\r\n    προγράμματος πλοήγησης ή άλλου ειδικού προγράμματος.\r\n</p>\r\n<strong>\r\n    ΒΗΜΑ 1ο. Δημιουργία του κώδικα σε JAVA\r\n</strong>\r\n<p>\r\n    Η δημιουργία του κώδικά μας γίνεται με οποιοδήποτε συντάκτη κειμένου (text editor) ή ένα Notepad. Δεν είναι\r\n    απαραίτητη η χρήση κάποιου συγκεκριμένου προγράμματος, τα οποία όμως παρέχουν αρκετές βοηθητικές λειτουργίες για την\r\n    σύνταξη και τον έλεγχο του κώδικα.\r\n</p>\r\n<p>\r\n    Για το παρακάτω παράδειγμα χρησιμοποιήθηκε το <a href=\"https://notepad-plus-plus.org/\"\r\n        target=\"_blank\">NotePad++</a>. Μέσα στον συντάκτη γράφουμε τον παρακάτω κώδικα δίνοντας προσοχή στα κεφαλαία και\r\n    τα μικρά γράμματα (case sensitive).\r\n</p>\r\n<code>\r\n    Class hello \r\n    { \r\n        public static void main (String args[])   \r\n        {  \r\n            System.out.println(“Hello World”);  \r\n        } \r\n    } \r\n</code>\r\n<p>\r\n    Μόλις τελειώσουμε με την συγγραφή του κώδικα τον αποθηκεύουμε με όνομα <file>hello.java</file>, σε έναν υποφάκελο έστω ότι τον\r\n    λέμε myprograms_Java. Το όνομα που θα έχει το αρχείο πρέπει αν είναι το ίδιο με το όνομα που έχουμε δώσει στην κλάση\r\n    «Class hello», καθώς και η κατάληξη του αρχείου που αποθηκεύουμε πρέπει αν είναι <file>.java</file> .\r\n</p>\r\n<strong>\r\n    BHMA 2ο. Μεταγλώττιση\r\n</strong>\r\n<p>\r\n    Για να γίνει η μεταγλώττιση του αρχείου μας πρέπει να ανοίξουμε ένα παράθυρο εντολών (cmd). </p>\r\n<p>\r\n    Μόλις ανοίξουμε το παράθυρο εντολών μέσω αυτού πηγαίνουμε στον υποκατάλογο που έχουμε αποθηκεύσει το Java αρχείο\r\n    μας, στην δική μου περίπτωση D:myprograms_Javachapter1.\r\n</p>\r\n<p>\r\n    Ο μεταγλωττιστής που έχει η Java ονομάζεται javac (Java Compiler). Για να μεταγλωττίσουμε το αρχείο <file>hello.java</file>,\r\n    γράφουμε στην γραμμή εντολών <code>Javac hello.java</code> \r\n</p>\r\n<p>\r\n    Αν το πρόγραμμα που γράψαμε δεν έχει λάθη, ο μεταγλωττιστής δημιουργεί ένα αρχείο κώδικα byte, το οποίο έχει το ίδιο\r\n    όνομα με το πηγαίο αρχείο μας και προέκταση <i>.class</i>. Δημιουργείται δηλαδή το αρχείο <file>hello.class</file> το\r\n    οποίο μπορούμε να\r\n    δούμε με την εντολή dir.\r\n</p>\r\n<strong>\r\n    ΒΗΜΑ 3ο. Εκτέλεση\r\n</strong>\r\n<p>\r\n    Για να εκτελέσουμε το αρχείο που δημιουργήσαμε σε byte δηλαδή το αρχείο <file>hello.class</file> καλούμε από το παράθυρο της\r\n    γραμμής εντολών τον διερμηνευτή της JDK ο οποίος ονομάζεται java, μαζί με το όνομα του αρχείου κώδικα byte. Γράφουμε\r\n    λοιπόν <code>Java hello</code>. Αν όλα έχουν γίνει σωστά, βλέπουμε στην οθόνη την φράση “Hello World”\r\n</p>\r\n<p>\r\n    Κάθε εφαρμογή της Java ξεκινάει πάντα με τον ορισμό της κλάσης, η οποία περιέχει μια μέθοδο που ονομάζεται <code>main()</code>.\r\n    Το όνομα της κλάσης μπορεί να είναι οποιοδήποτε, όμως η μέθοδος που εκτελείτε πρώτη είναι πάντοτε η <code>main()</code>.\r\n<ol>\r\n    <li>\r\n        Ορισμός της <b>κλάσης</b> Hello, περιλαμβάνει μόνο μια μέθοδο, την <code>main()</code>\r\n    </li>\r\n    <li>\r\n        Οι αγκύλες περικλείουν κομμάτια κώδικα και τοποθετούνται ανά ζεύγη.\r\n    </li>\r\n    <li>\r\n        Η λέξη <code>public</code> δηλώνει ότι η μέθοδος είναι προσπελάσιμη από παντού.\r\n    </li>\r\n    <li>\r\n        Η λέξη <code>static</code> δηλώνει ότι η μέθοδος είναι προσπελάσιμη ακόμα και αν δεν υπάρχουν αντικείμενα στην κλάση.\r\n    </li>\r\n    <li>\r\n        Η λέξη <code>void</code> σημαίνει ότι δεν επιστρέφετε κάποια τιμή.\r\n    </li>\r\n</ol>\r\n</p>\r\n<p>\r\n    Εντός της μεθόδου <code>main()</code> υπάρχει η εντολή <code>System.out.println(\"Hello world\");</code>\r\n<ol>\r\n    <li>\r\n        <code>System</code> είναι το όνομα μιας βασικής κλάσης που περιλαμβάνει αντικείμενα και μεταβλητές για υποστήριξη εισαγωγής\r\n        δεδομένων από το πληκτρολόγιο και για την έξοδο χαρακτήρων προς την οθόνη.\r\n    </li>\r\n    <li>\r\n        Το αντικείμενο <code>out</code> δηλώνει την έξοδο (οθόνη) και είναι μέρος του system.\r\n    </li>\r\n    <li>\r\n        H <code>println()</code> είναι μέθοδος του αντικειμένου out και τυπώνει στην οθόνη την φράση που βρίσκεται μέσα στην\r\n        παρένθεση.\r\n    </li>\r\n    <li>\r\n        Με το <code>;</code> πρέπει να τελειώνει κάθε εντολή. Δεν τελειώνουν όλες οι γραμμές το <code>;</code> Διότι δεν αποτελούνται όλες\r\n        οι γραμμές από εντολές, μερικές περιέχουν και ορισμούς.\r\n    </li>\r\n</ol>\r\n</p>', '<p>\r\n    Παρακάτω θα δημιουργήσουμε μια εφαρμογή σε Java, το “Hello World”, η οποία θα τρέχει αυτόματα χωρίς να κάνει χρήση\r\n    προγράμματος πλοήγησης ή άλλου ειδικού προγράμματος.\r\n</p>\r\n<strong>\r\n    ΒΗΜΑ 1ο. Δημιουργία του κώδικα σε JAVA\r\n</strong>\r\n<p>\r\n    Η δημιουργία του κώδικά μας γίνεται με οποιοδήποτε συντάκτη κειμένου (text editor) ή ένα Notepad. Δεν είναι\r\n    απαραίτητη η χρήση κάποιου συγκεκριμένου προγράμματος, τα οποία όμως παρέχουν αρκετές βοηθητικές λειτουργίες για την\r\n    σύνταξη και τον έλεγχο του κώδικα.\r\n</p>\r\n<p>\r\n    Για το παρακάτω παράδειγμα χρησιμοποιήθηκε το <a href=\"https://notepad-plus-plus.org/\"\r\n        target=\"_blank\">NotePad++</a>. Μέσα στον συντάκτη γράφουμε τον παρακάτω κώδικα δίνοντας προσοχή στα κεφαλαία και\r\n    τα μικρά γράμματα (case sensitive).\r\n</p>\r\n<xmp>\r\n    Class hello \r\n    { \r\n        public static void main (String args[])   \r\n        {  \r\n            System.out.println(“Hello World”);  \r\n        } \r\n    } \r\n</xmp>\r\n<p>\r\n    Μόλις τελειώσουμε με την συγγραφή του κώδικα τον αποθηκεύουμε με όνομα <file>hello.java</file>, σε έναν υποφάκελο έστω ότι τον\r\n    λέμε myprograms_Java. Το όνομα που θα έχει το αρχείο πρέπει αν είναι το ίδιο με το όνομα που έχουμε δώσει στην κλάση\r\n    «Class hello», καθώς και η κατάληξη του αρχείου που αποθηκεύουμε πρέπει αν είναι <file>.java</file> .\r\n</p>\r\n<strong>\r\n    BHMA 2ο. Μεταγλώττιση\r\n</strong>\r\n<p>\r\n    Για να γίνει η μεταγλώττιση του αρχείου μας πρέπει να ανοίξουμε ένα παράθυρο εντολών (cmd). </p>\r\n<p>\r\n    Μόλις ανοίξουμε το παράθυρο εντολών μέσω αυτού πηγαίνουμε στον υποκατάλογο που έχουμε αποθηκεύσει το Java αρχείο\r\n    μας, στην δική μου περίπτωση D:myprograms_Javachapter1.\r\n</p>\r\n<p>\r\n    Ο μεταγλωττιστής που έχει η Java ονομάζεται javac (Java Compiler). Για να μεταγλωττίσουμε το αρχείο <file>hello.java</file>,\r\n    γράφουμε στην γραμμή εντολών <code>Javac hello.java</code> \r\n</p>\r\n<p>\r\n    Αν το πρόγραμμα που γράψαμε δεν έχει λάθη, ο μεταγλωττιστής δημιουργεί ένα αρχείο κώδικα byte, το οποίο έχει το ίδιο\r\n    όνομα με το πηγαίο αρχείο μας και προέκταση <i>.class</i>. Δημιουργείται δηλαδή το αρχείο <file>hello.class</file> το\r\n    οποίο μπορούμε να\r\n    δούμε με την εντολή dir.\r\n</p>\r\n<strong>\r\n    ΒΗΜΑ 3ο. Εκτέλεση\r\n</strong>\r\n<p>\r\n    Για να εκτελέσουμε το αρχείο που δημιουργήσαμε σε byte δηλαδή το αρχείο <file>hello.class</file> καλούμε από το παράθυρο της\r\n    γραμμής εντολών τον διερμηνευτή της JDK ο οποίος ονομάζεται java, μαζί με το όνομα του αρχείου κώδικα byte. Γράφουμε\r\n    λοιπόν <code>Java hello</code>. Αν όλα έχουν γίνει σωστά, βλέπουμε στην οθόνη την φράση “Hello World”\r\n</p>\r\n<p>\r\n    Κάθε εφαρμογή της Java ξεκινάει πάντα με τον ορισμό της κλάσης, η οποία περιέχει μια μέθοδο που ονομάζεται <code>main()</code>.\r\n    Το όνομα της κλάσης μπορεί να είναι οποιοδήποτε, όμως η μέθοδος που εκτελείτε πρώτη είναι πάντοτε η <code>main()</code>.\r\n<ol>\r\n    <li>\r\n        Ορισμός της <b>κλάσης</b> Hello, περιλαμβάνει μόνο μια μέθοδο, την <code>main()</code>\r\n    </li>\r\n    <li>\r\n        Οι αγκύλες περικλείουν κομμάτια κώδικα και τοποθετούνται ανά ζεύγη.\r\n    </li>\r\n    <li>\r\n        Η λέξη <code>public</code> δηλώνει ότι η μέθοδος είναι προσπελάσιμη από παντού.\r\n    </li>\r\n    <li>\r\n        Η λέξη <code>static</code> δηλώνει ότι η μέθοδος είναι προσπελάσιμη ακόμα και αν δεν υπάρχουν αντικείμενα στην κλάση.\r\n    </li>\r\n    <li>\r\n        Η λέξη <code>void</code> σημαίνει ότι δεν επιστρέφετε κάποια τιμή.\r\n    </li>\r\n</ol>\r\n</p>\r\n<p>\r\n    Εντός της μεθόδου <code>main()</code> υπάρχει η εντολή <code>System.out.println(\"Hello world\");</code>\r\n<ol>\r\n    <li>\r\n        <code>System</code> είναι το όνομα μιας βασικής κλάσης που περιλαμβάνει αντικείμενα και μεταβλητές για υποστήριξη εισαγωγής\r\n        δεδομένων από το πληκτρολόγιο και για την έξοδο χαρακτήρων προς την οθόνη.\r\n    </li>\r\n    <li>\r\n        Το αντικείμενο <code>out</code> δηλώνει την έξοδο (οθόνη) και είναι μέρος του system.\r\n    </li>\r\n    <li>\r\n        H <code>println()</code> είναι μέθοδος του αντικειμένου out και τυπώνει στην οθόνη την φράση που βρίσκεται μέσα στην\r\n        παρένθεση.\r\n    </li>\r\n    <li>\r\n        Με το <code>;</code> πρέπει να τελειώνει κάθε εντολή. Δεν τελειώνουν όλες οι γραμμές το <code>;</code> Διότι δεν αποτελούνται όλες\r\n        οι γραμμές από εντολές, μερικές περιέχουν και ορισμούς.\r\n    </li>\r\n</ol>\r\n</p>', 1),
(4, 'Δημιουργία ενός Java Applet', 2, '', '<p>\r\n    Η δημιουργία ενός java applet διαφέρει αρκετά από αυτήν της δημιουργίας μια εφαρμογής. Τα java applet εκτελούνται μέσα από μια σελίδα παγκόσμιου ιστού και έχουν άλλους κανόνες εμφάνισης και συμπεριφοράς. Για να δημιουργήσουμε για παράδειγμα το “Hello\r\n    World” σε μια ιστοσελίδα, θα πρέπει να οριοθετήσουμε τον χώρο που θα εμφανιστεί και εν συνεχεία να το τυπώσουμε με γραφικό τρόπο. Παρακάτω θα δημιουργηθεί το “Hello World” με applet.\r\n</p>\r\n<strong>\r\n    ΒΗΜΑ 1ο. Δημιουργία του πηγαίου κώδικα\r\n</strong>\r\n<p>\r\n    Με ένα συντάκτη κειμένου (π.χ. notepad++) συντάσσουμε το παρακάτω κείμενο\r\n</p>\r\n<xmp>\r\nimport java.applet.Applet; \r\nimport java.awt.Graphics; \r\n\r\npublic class helloApplet extends Applet \r\n{ \r\n    public void paint(Graphics g) \r\n    { \r\n        g.drawString(\"Hello World!!!\",10 ,40); \r\n    } \r\n} \r\n</xmp>\r\n<p>\r\n    Στη συνέχεια αποθηκεύουμε των κώδικα στον φάκελο με της εφαρμογές με όνομα\r\n    <file>helloApplet.java</file>.\r\n</p>\r\n\r\n<strong>\r\n    ΒΗΜΑ 2ο. Μεταγλώττιση\r\n</strong>\r\n<p>\r\n    Όπως και προηγουμένως ανοίγουμε ένα παράθυρο γραμμής εντολών, πηγαίνουμε στον φάκελο που βρίσκεται το αρχείο\r\n    <file>helloApplet.java</file> και το μεταγλωττίζουμε γράφοντας <code>Javac helloApplet.java</code>. Αν δεν υπάρξει κάποιο συντακτικό σφάλμα, θα δημιουργηθεί το αρχείο\r\n    <file>helloApplet.class</file>. Στην περίπτωση που δημιουργηθούν κάποια σφάλματα, πηγαίνουμε στον συντάκτη, διορθώνουμε τον κώδικα και επαναλαμβάνουμε την διαδικασία.\r\n</p>\r\n<strong>\r\n    ΒΗΜΑ 3ο. Ενσωμάτωση του applet σε μια ιστοσελίδα\r\n</strong>\r\n<p>\r\n    Μια ιστοσελίδα δημιουργείται με μια ιδική γλώσσα η οποία ονομάζεται HTML (Hyper Text Markup Language, γλώσσα σημείωσης υποκειμένου). Ο κώδικας της γλώσσας αυτής γράφετε με έναν συντάκτη κειμένου (notepad, TextPad κ.α.) ή με ένα επεξεργαστή κειμένου όπως\r\n    το Word. Το αρχείο το οποίο δημιουργείται έχει την κατάληξη\r\n    <file>.html</file> ή\r\n    <file>htm</file>. Ένα αρχείο της γλώσσας HTML αποτελείται από μια ομάδα στοιχείων τα οποία με την σειρά τους προσδιορίζονται από ετικέτες. Το έγγραφο της HTML αρχίζει πάντα με την ετικέτα <code>&lt;HTML&gt;</code> και κλείνει με την ετικέτα\r\n    <code>&lt;/HTML&gt;</code>. Το <code>/</code> δηλώνει το τέλος της εκάστοτε ετικέτας. Εντός του εγγράφου βρίσκεται η ενότητα <code>&lt;HEAD&gt;</code> η οποία περιέχει πληροφορίες για την ιστοσελίδα, καθώς και η ενότητα <code>&lt;BODY&gt;</code> η\r\n    οποία περιέχει το κύριο κορμό του εγγράφου. Για να ενσωματώσουμε ένα applet σε ένα HTML χρησιμοποιούμε την ετικέτα <code>&lt;APPLET&gt;</code>.\r\n</p>\r\n<p>\r\n    Ανοίγουμε λοιπόν τον συντάκτη κειμένου και δημιουργούμε το παρακάτω HTML\r\n</p>\r\n<xmp>\r\n<HTML> \r\n    <HEAD>        \r\n        <TITLE>Ένα πολύ απλό πρόγραμμα!</TITLE>      \r\n    </HEAD>       \r\n    <BODY>    \r\n        <P>     \r\n        <APPLET code=\"helloApplet.class\" WIDTH=300 HEIGHT=200></APPLET>\r\n        </P> \r\n    </BODY> \r\n</HTML> \r\n</xmp>\r\n<p>\r\n    Για να δημιουργήσουμε ένα έγγραφο HTML, ονομάζουμε το αρχείο μας με οποιοδήποτε όνομα θέλουμε, σε αντίθεση με η java αρχείο και στη συνέχεια αποθηκεύουμε το έγγραφο με τη κατάληξη\r\n    <file>.html</file>.\r\n</p>\r\n<strong>\r\n    ΒΗΜΑ 4ο. Πως βλέπουμε το έγγραφο HTML που δημιουργήσαμε;\r\n</strong>\r\n<p>\r\n    Για να δούμε το έγγραφο HTML που δημιουργήσαμε μπορούμε να χρησιμοποιήσουμε 2 τρόπους.\r\n    <ul>\r\n        <li>\r\n            Κάνουμε χρήση του εργαλείου AppletViewer του JDK. Για να καλέσουμε το εργαλείο αυτό πηγαίνουμε στην γραμμή εργασιών και γράφουμε <code>appletviewer hello.html</code>\r\n        </li>\r\n        <li>\r\n            Χρησιμοποιούμε ένα πρόγραμμα περιήγησης στο Internet με υποστήριξη Java (Google Chrome, Firefox). Αφού το φορτώσουμε επιλέγουμε τη διαταγή Αρχείο -> Άνοιγμα (Αρχείο -> Άνοιγμα αρχείου, για τον Firefox). Στο πλαίσιο του διαλόγου που εμφαανίζεται πατάμε\r\n            την αναζήτηση και βρίσκουμε το αρχείο .html στο φάκελο που το έχουμε τοποθετήσει.\r\n        </li>\r\n    </ul>\r\n</p>', 1),
(5, 'Aλφαριθμητική μεταβλητή', 1, 'Καταχωρήστε σε μια μεταβλητή το όνομά σας και τυπώστε την στην γραμμή εντολών. ', '<xmp>\r\n    /* Αυτό  είναι πρόγραμμα που χρησιμοποιεί αλφαριθμητική μεταβλητή */ \r\n    public class hello1 {\r\n    \r\n        public static void main(String args[]) {\r\n    \r\n            String name;\r\n    \r\n            //Βάλτε το δικό σας όνομα \r\n            name = \"Kostas\";\r\n    \r\n            System.out.println(\"Hello\" + name);\r\n        }\r\n    }\r\n</xmp>\r\n<p>Βήματα\r\n    <ol>\r\n        <li>Δημιουργούμε τον κώδικα και τον ονομάζουμε <file>hello1.java</file></li>\r\n        <li>το μεταγλωττίζουμε μέσω της γραμμής εντολών με την εντολή <code>hello1.java</code></li>\r\n        <li>Στη συνέχεια εκτελούμε την εντολή <code>Java hello1</code> για να εκτυπωθεί η μεταβλητή.  </li>\r\n    </ol>\r\n</p>\r\n<p>Ανάλυση</p>\r\n<p>Παρακάτω εξετάζουμε δύο από αρκετές μεθόδους που υπάρχουν για να βάζουμε σχόλια στον κώδικά μας\r\n    <ul>\r\n        <li>Περικλείουμε τα σχόλια μεταξύ /* και */ . Τα σχόλια αυτά μπορούν να επεκταθούν σε όσες γραμμές θέλουμε. Π.χ. <code>/* Βάλτε το δικό σας όνομα */</code></li>\r\n        <li>Τοποθετούμε μπροστά δύο κάθετους (//). Αυτού του είδους των σχολίων εκτείνονται μόνο στην τρέχουσα γραμμή. Π.χ. <code>// Βάλτε το δικό σας όνομα</code></li>\r\n    </ul>\r\n</p>\r\n<p>\r\n    Στο κύριο σώμα του κώδικα υπάρχει\r\n    <br/>\r\n    <code>String name;</code>\r\n    <br/>\r\n    <code>Name= \"Kostas\";</code>\r\n    <br/>\r\n    Στην αρχή δηλώνουμε μια μεταβλητή τύπου string και την ονομάζουμε name, και στην συνέχεια δίνουμε σε αυτή την μεταβλητή την τιμή \"Kostas\". Η εκχώρηση (assigned) της τιμής γίνεται με το σύμβολο <code>=</code>, όπου αριστερά αυτού μπαίνει το όνομα της μεταβλητής και στα δεξιά η τιμή της. Ίδιο ακριβώς αποτέλεσμα θα είχαμε άμα γράφαμε \r\n    <br/>\r\n    <code>String Name= \"Kostas\";</code>\r\n</p>\r\n<p>\r\n    Στην Java υπάρχουν δύο βασικές κατηγορίες μεταβλητών οι μεταβλητές μέλη (member variables) και οι τοπικές μεταβλητές (local variables)\r\n    <ul>\r\n        <li>Member Variables: Αν δεν του δώσουμε εμείς τιμή, παίρνουν από το σύστημα </li>\r\n        <li>Local variables: Δεν παίρνουν τιμές από το σύστημα και αν δεν τους δώσουμε εμείς αρχική τιμή ο μεταγλωττιστής εμφανίζει μήνυμα λάθους. </li>\r\n    </ul>\r\n</p>\r\n<p>\r\n    <code>System.out.println(\"Hello\" + name); </code>\r\n    <br/>\r\n    Το σημείο <code>+</code>  είναι ένας  τελεστής ο οποίος ενώνει την λέξη hello με την τιμή που έχει η μεταβλητή name (δηλαδή: Hello Kostas) \r\n</p>', 2),
(30, 'Απόδοση αρχικών τιμών στον πίνακα', 1, 'Να δημιουργηθεί ένας πίνακας ακεραίων , να του αποδοθεί όνομα samples και να δέχεται είκοσι στοιχεία. Κάθε ένα από τα στοιχεία να παίρνει μια τυχαία τιμή με εύρος από το 1 μέχρι το 49 και να τοποθετείται στον πίνακα. ', '<xmp>\r\npublic class RandomArray {\r\n\r\n    public static void main(String[] args) {\r\n\r\n        // orismos tou pinaka\r\n        int samples[] = new int[20];  \r\n        int number;\r\n\r\n        //arxikopoioume ton pinaka \r\n        for (int i = 0; i < 20; i++) {\r\n            samples[i] = 0;\r\n        }\r\n\r\n        //vazoumai tyxaious arithmous \r\n        for (int i = 0; i < 20; i++) {\r\n            number = (int) (Math.random() * 49) + 1;\r\n            samples[i] = number;\r\n        }\r\n\r\n        /* ektypwnoume ton pinaka me tous tyxaious arithmous, anti gia to i<20, \r\n         vazoume pio geniko orismo i<samples.length */ \r\n        for (int i = 0; i < samples.length; i++) {\r\n            System.out.println(samples[i]);\r\n        }\r\n    }\r\n}\r\n</xmp>', 4),
(31, 'Πίνακες πολλών διαστάσεων', 2, 'Να δημιουργηθεί πίνακας τύπου int ο οποίος να έχει 4 γραμμές και 5 στήλες. Το στοιχείο σε κάθε θέση αν προκύπτει από το άθροισμα της γραμμής και της στήλης.  ', '<xmp>\r\npublic class TowDimArray {\r\n\r\n    public static void main(String[] args) {\r\n\r\n        int[][] M; //orismos toy pinaka \r\n        M = new int[4][5]; //kataxwrish pinaka \r\n\r\n        for (int row = 0; row < 4; row++) {\r\n            for (int col = 0; col < 5; col++) {\r\n                M[row][col] = row + col; //prosthesi gramis kai stilis \r\n            }\r\n        }\r\n\r\n        //ektypwsh \r\n        for (int row = 0; row < 4; row++) {\r\n            for (int col = 0; col < 5; col++) {\r\n                System.out.print(M[row][col] + \" \");\r\n            }\r\n            System.out.println();\r\n        }\r\n    }\r\n}\r\n</xmp>', 4),
(32, 'Πακετάρισμα κλάσης', 1, 'Να δημιουργηθεί πακέτο με όνομα geometry. Στο πακέτο αυτό αν προστεθεί η κλάση Circle2(όμοια κλάση με την Circle). Μετά να δημιουργηθεί πρόγραμμα το οποία να κάνει χρήση της κλάσης Circle2, κάνοντας εισαγωγή στο πρόγραμμα το πακέτο geometry. ', '<b>BHMA 1ο. </b>\r\n<p>Δημιουργείτε η κλάση <code>Circle2.java</code>. Τοποθετείται στην αρχή της κλάσης αυτής η λέξη <code>package</code> μαζί με το όνομα που θα δοθεί στο πακέτο. Έστω ότι το όνομα του πακέτου είναι το <code>geometry</code>.</p>\r\n<xmp>\r\npackage geometry;\r\n\r\npublic class Circle2 {\r\n\r\n    double Pi = 3.14;\r\n    double radius;\r\n    double x;\r\n    double y;\r\n\r\n    //dimiourgeia kataskeuasti \r\n    public Circle2(double r1, double x1, double y1) {\r\n        radius = r1;\r\n        x = x1;\r\n        y = y1;\r\n    }\r\n\r\n    public Circle2(double r2) {\r\n        x = 0.0;\r\n        y = 0.0;\r\n        radius = r2;\r\n    }\r\n\r\n    public double area() {\r\n        return Pi * radius * radius;\r\n    }\r\n}\r\n</xmp>\r\n\r\n<b>BHMA 2ο. </b>\r\n<p>\r\nΔημιουργούμε ένα νέο πρόγραμμα <code>testCircle2.java</code> και καλούμε την κλάση κάνοντας χρήση της λέξης <code>import</code>. Έτσι έχουμε \r\n</p>\r\n<xmp>\r\nimport geometry.Circle2; \r\n\r\npublic class testCircle2 {\r\n\r\n    public static void main(String[] args) {\r\n\r\n        Circle2 troxos = new Circle2(5.0, 1.0, 1.0);\r\n        Circle2 roda = new Circle2(8.0);\r\n\r\n        //ektyposh emvadou kathe kyklou \r\n        System.out.println(\"Area of troxos = \" + troxos.area());\r\n        System.out.println(\"Area of roda = \" + roda.area());\r\n    }\r\n}\r\n</xmp>', 5),
(33, 'Η κληρονομικότητα των κλάσεων', 2, '', '<p>Αρχικά δημιουργείτε η κλάση <code>Point.java</code></p>\r\n<xmp>\r\npublic class Point {\r\n\r\n    protected double x;\r\n    protected double y;\r\n\r\n    //o prwtos kataskeuastis \r\n    public Point(double xcor, double ycor) {\r\n        x = xcor;\r\n        y = ycor;\r\n    }\r\n\r\n    //o deuteros kataskeuastis \r\n    public Point() {\r\n        x = 0.0;\r\n        y = 0.0;\r\n    }\r\n\r\n    //o tritos kaatskeuastis \r\n    public Point(Point point) {\r\n        x = point.x;\r\n        y = point.y;\r\n    }\r\n\r\n    //methodos gia na paroume tin synistosa x \r\n    public double getX() {\r\n        return x;\r\n    }\r\n\r\n    //methodos gia na paroume tin synistosa y \r\n    public double getY() {\r\n        return y;\r\n    }\r\n\r\n    //methodos gia na metatrepsoume tis syntetagmenes tou simeiou se alfarithitika \r\n    public String toString() {\r\n        return \"(\" + x + \",\" + y + \")\";\r\n    }\r\n}\r\n</xmp>\r\n\r\n<p>Στη συνέχεια δημιουργείτε η κλάση <code>Cycle.java</code></p>\r\n<xmp>\r\npublic class Cycle extends Point {\r\n\r\n    protected double radius;\r\n    static double Pi = 3.14;\r\n\r\n    //prwtos kataskeuastis \r\n    public Cycle(double x1, double y1, double r1) {\r\n        super(x1, y1);\r\n        radius = (r1 >= 0 ? r1 : 0.0);\r\n    }\r\n\r\n    //deuteros kataskeuastis \r\n    public Cycle() {\r\n        radius = 0.0;\r\n    }\r\n\r\n    public double area() {\r\n        return Pi * radius * radius;\r\n    }\r\n\r\n    public String toString() {\r\n        return \"x= \" + x + \",\" + \"y= \" + y + \",\" + \"r=\" + radius;\r\n    }\r\n}\r\n</xmp>\r\n<p>\r\nΗ λέξη <code>super</code> χρησιμοποιείτε για να γίνει κλήση μελών μιας υπερκλάσης μια κλάσης. Όταν χρησιμοποιείτε ως <code>super()</code>, καλείτε ο κατασκευαστής της υπερκλάσης, όταν χρησιμοποιείτε ως <code>super.f()</code> καλεί την συνάρτηση <code>f()</code>, που έχει οριστεί στην υπερκλάση. \r\n</p>\r\n<p>\r\nΣτο παράδειγμα, χρησιμοποιώντας την εντολή <code>super(x1, y1)</code>, έγινε κλήση του κατασκευαστή της <code>Point</code> της υπερκλάσης της <code>Cycle</code> και περάστηκαν οι τιμές <code>x1</code>, <code>y1</code> για να δοθούν αρχικές τιμές στις μεταβλητές <code>x</code>, <code>y</code>.  \r\n</p>\r\n\r\n<p>Συνεχίζοντας δημιουργείτε η κλάση <code>ColorCycle.java</code></p>\r\n<xmp>\r\npublic class ColorCycle extends Cycle {\r\n\r\n    protected String color;\r\n\r\n    public ColorCycle(double x2, double y2, double r2, String c) {\r\n        super(x2, y2, r2);\r\n        color = c;\r\n    }\r\n\r\n    public String getColor() {\r\n        return color;\r\n    }\r\n\r\n    public String toString() {\r\n        return \"x=\" + x + \",\" + \"y=\" + y + \",\" + \"r=\" + radius + \",\" + \"color=\" + color;\r\n    }\r\n}\r\n</xmp>\r\n<p>Για την δοκιμή των προηγούμενων δημιουργείτε πρόγραμμα <code>showInheritance.java</code></p>\r\n<xmp>\r\npublic class showInheritance {\r\n\r\n    public static void main(String[] args) {\r\n\r\n        Point p1;\r\n        Cycle c1;\r\n        ColorCycle colorc1;\r\n\r\n        p1 = new Point(50.5, 70.5);\r\n        c1 = new Cycle(40.0, 50.0, 70.5);\r\n        colorc1 = new ColorCycle(30.0, 40.0, 20.0, \"Red\");\r\n\r\n        //sydetagmenes tou simeiou se morfi string \r\n        System.out.println(\"The point:\" + p1.toString());\r\n\r\n        //sydetagmenes tou kyklou c1 kai i aktina tou, parakampsi tiw methodou toString() \r\n        System.out.println(\"The cycle:\" + c1.toString());\r\n\r\n        //emvadon tou kikloy me tin xrisi tiw area() \r\n        System.out.println(\"The cycle area:\" + c1.area());\r\n\r\n        //parakampsi methodou toString() , stoixeia tou colorc1 \r\n        System.out.println(\"The colorcycle:\" + colorc1.toString());\r\n\r\n        //emvadon tou colorc1, xrisi tiw methodou area apo tin yperklasi \r\n        System.out.println(\"The colorcycle.area=\" + colorc1.area());\r\n\r\n        //emfanisi xrwmatos kykloy me tin methodo getcolor \r\n        System.out.println(\"The colorcycle color=\" + colorc1.getColor());\r\n    }\r\n}\r\n</xmp>', 5),
(6, 'Οι μοναδιαίοι τελεστές αύξησης και μείωσης', 2, 'Να δημιουργηθεί πρόγραμμα το οποίο να δείχνει την δράση των τελεστών αύξησης και μείωσης', '<xmp>\r\nclass showInDec {\r\n\r\n    public static void main(String args[]) {\r\n\r\n        int x = 10;\r\n        int y;\r\n\r\n        y = ++x;\r\n\r\n        System.out.println(\"x = \" + x);\r\n        System.out.println(\"y = \" + y);\r\n        System.out.println(\"---------\");\r\n\r\n        y = x++;\r\n\r\n        System.out.println(\"x = \" + x);\r\n        System.out.println(\"y = \" + y);\r\n        System.out.println(\"---------\");\r\n\r\n        y = --x;\r\n\r\n        System.out.println(\"x = \" + x);\r\n        System.out.println(\"y = \" + y);\r\n        System.out.println(\"---------\");\r\n\r\n        y = x--;\r\n\r\n        System.out.println(\"x = \" + x);\r\n        System.out.println(\"y = \" + y);\r\n        System.out.println(\"---------\");\r\n    }\r\n}\r\n</xmp>\r\n<p>Βήματα\r\n    <ol>\r\n        <li>Δημιουργούμε τον κώδικα και τον ονομάζουμε\r\n            <file>showInDec.java</file>\r\n        </li>\r\n        <li>το μεταγλωττίζουμε μέσω της γραμμής εντολών με την εντολή <code>showInDec.java</code></li>\r\n        <li>Στη συνέχεια εκτελούμε την εντολή <code>Java showInDec</code>.</li>\r\n    </ol>\r\n</p>', 2),
(7, 'Οι τελεστές των αριθμητικών πράξεων', 3, 'Να δημιουργηθεί ένα πρόγραμμα, που δίνονται τιμές σε δύο ακέραιες μεταβλητές και στη συνέχεια ν α υπολογίζεται και ν τυπώνεται το άθροισμα, η διαφορά, το γινόμενο, το ακέραιο υπόλοιπο και το πηλίκο. Για το άθροισμα, τη διαφορά, το γινόμενο, και το ακέραιο υπόλοιπο να χρησιμοποιηθούν ακέραιες τιμές, ενώ για το πηλίκο οι τιμές να είναι double ', '<xmp>\r\nclass showArithmetic {\r\n\r\n    public static void main(String args[]) {\r\n\r\n        int i = 1242;\r\n        int j = 256;\r\n        int sum; //άθροισμα \r\n        int dif; //διαφορά \r\n        long prod; //γινόμενο \r\n        long mod; //modulus \r\n        double quot; //πηλίκο \r\n\r\n        //Υπολογισμοί \r\n        sum = i + j;\r\n        dif = i - j;\r\n        prod = i * j;\r\n        mod = i % j;\r\n        quot = i / j;\r\n\r\n        //Εκτύπωση αποτελεσμάτων \r\n        System.out.println(\"The sum is\" + sum);\r\n        System.out.println(\"The dif is\" + dif);\r\n        System.out.println(\"The prod is\" + prod);\r\n        System.out.println(\"The mod is\" + mod);\r\n        System.out.println(\"The quot is\" + quot);\r\n    }\r\n}\r\n</xmp>\r\n<p>Βήματα\r\n    <ol>\r\n        <li>Δημιουργούμε τον κώδικα και τον ονομάζουμε\r\n            <file>showArithmetic.java</file>\r\n        </li>\r\n        <li>το μεταγλωττίζουμε μέσω της γραμμής εντολών με την εντολή <code>showArithmetic.java</code></li>\r\n        <li>Στη συνέχεια εκτελούμε την εντολή <code>Java showArithmetic</code>.</li>\r\n    </ol>\r\n</p>', 2),
(8, 'Eκχωρήσεις', 4, '', '<xmp>\r\nclass showAssignments {\r\n\r\n    public static void main(String args[]) {\r\n\r\n        int x = 10;\r\n        int y = 20;\r\n\r\n        y += x;\r\n\r\n        System.out.println(\"y=\" + y);\r\n        System.out.println(\"---------\");\r\n\r\n        y -= x;\r\n\r\n        System.out.println(\"y=\" + y);\r\n        System.out.println(\"---------\");\r\n\r\n        y *= x;\r\n\r\n        System.out.println(\"y=\" + y);\r\n        System.out.println(\"---------\");\r\n\r\n        y /= x;\r\n\r\n        System.out.println(\"y=\" + y);\r\n        System.out.println(\"---------\");\r\n    }\r\n}\r\n</xmp>\r\n<p>Βήματα\r\n    <ol>\r\n        <li>Δημιουργούμε τον κώδικα και τον ονομάζουμε\r\n            <file>showAssignments.java</file>\r\n        </li>\r\n        <li>το μεταγλωττίζουμε μέσω της γραμμής εντολών με την εντολή <code>showAssignments.java</code></li>\r\n        <li>Στη συνέχεια εκτελούμε την εντολή <code>Java showAssignments</code>. </li>\r\n    </ol>\r\n</p>', 2),
(9, 'Λογικοί τελεστές', 5, '', '<xmp>\r\nclass showBoolean {\r\n\r\n    public static void main(String args[]) {\r\n\r\n        boolean a, b, c, d;\r\n\r\n        a = (4 == 2 + 2) && (3 == 1 + 2);\r\n        System.out.println(\"a= \" + a);\r\n\r\n        b = (4 > 5) || (4 > 7);\r\n        System.out.println(\"b= \" + b);\r\n\r\n        c = !b;\r\n        System.out.println(\"c= \" + c);\r\n\r\n        d = (4 + 2 == 6) ^ (5 + 2 == 17);\r\n        System.out.println(\"d= \" + d);\r\n    }\r\n}\r\n</xmp>\r\n<p>Βήματα\r\n    <ol>\r\n        <li>Δημιουργούμε τον κώδικα και τον ονομάζουμε\r\n            <file>showBoolean .java</file>\r\n        </li>\r\n        <li>το μεταγλωττίζουμε μέσω της γραμμής εντολών με την εντολή <code>showBoolean .java</code></li>\r\n        <li>Στη συνέχεια εκτελούμε την εντολή <code>Java showBoolean </code>.</li>\r\n    </ol>\r\n</p>', 2),
(10, 'Τελεστές δυαδικών ψηφίων', 6, 'Να βρεθεί η τιμή της παράστασης 0x1215 & 0x1101 ', '<table class=\"table table-striped\">\r\n    <tr>\r\n        <th>0x1215</th>\r\n        <td>0</td>\r\n        <td>0</td>\r\n        <td>0</td>\r\n        <td>1</td>\r\n        <td>0</td>\r\n        <td>0</td>\r\n        <td>1</td>\r\n        <td>0</td>\r\n        <td>0</td>\r\n        <td>0</td>\r\n        <td>0</td>\r\n        <td>1</td>\r\n        <td>0</td>\r\n        <td>1</td>\r\n        <td>0</td>\r\n        <td>1</td>\r\n    </tr>\r\n    <tr>\r\n        <th>0x1101</th>\r\n        <td>0</td>\r\n        <td>0</td>\r\n        <td>0</td>\r\n        <td>1</td>\r\n        <td>0</td>\r\n        <td>0</td>\r\n        <td>0</td>\r\n        <td>1</td>\r\n        <td>0</td>\r\n        <td>0</td>\r\n        <td>0</td>\r\n        <td>0</td>\r\n        <td>0</td>\r\n        <td>0</td>\r\n        <td>0</td>\r\n        <td>1</td>\r\n    </tr>\r\n    <tr>\r\n        <th></th>\r\n        <th>0</th>\r\n        <th>0</th>\r\n        <th>0</th>\r\n        <th>1</th>\r\n        <th>0</th>\r\n        <th>0</th>\r\n        <th>0</th>\r\n        <th>0</th>\r\n        <th>0</th>\r\n        <th>0</th>\r\n        <th>0</th>\r\n        <th>0</th>\r\n        <th>0</th>\r\n        <th>0</th>\r\n        <th>0</th>\r\n        <th>1</th>\r\n    </tr>\r\n\r\n</table>', 2),
(11, 'Χαρακτήρες', 7, '', '<xmp>\r\nclass showChar {\r\n\r\n    public static void main(String args[]) {\r\n\r\n        Char c1, c2, c3, c4, c5;\r\n\r\n        c1 = \'H\';\r\n        c2 = \'i\';\r\n        c3 = \'\\n\';\r\n        c4 = \'G\';\r\n        c5 = \'\\u0058\';\r\n\r\n        System.out.println(c1);\r\n        System.out.println(c2);\r\n        System.out.println(c3);\r\n        System.out.println(c4);\r\n        System.out.println(c5);\r\n    }\r\n}\r\n</xmp>\r\n\r\n<p>Βήματα\r\n    <ol>\r\n        <li>Δημιουργούμε τον κώδικα και τον ονομάζουμε\r\n            <file>showChar.java</file>\r\n        </li>\r\n        <li>το μεταγλωττίζουμε μέσω της γραμμής εντολών με την εντολή <code>showChar.java</code></li>\r\n        <li>Στη συνέχεια εκτελούμε την εντολή <code>Java showChar</code>.</li>\r\n    </ol>\r\n</p>', 2),
(12, 'Αλφαριθμητικά', 8, '', '<xmp>\r\nclass hello2 {\r\n\r\n    public static void main(String args[]) {\r\n\r\n        String name;\r\n\r\n        String greetings = \"Hello\";\r\n        name = \"Kostas\";\r\n\r\n        System.out.println(greetings + name);\r\n    }\r\n}\r\n</xmp>\r\n\r\n<p>Βήματα\r\n    <ol>\r\n        <li>Δημιουργούμε τον κώδικα και τον ονομάζουμε\r\n            <file>hello2.java</file>\r\n        </li>\r\n        <li>το μεταγλωττίζουμε μέσω της γραμμής εντολών με την εντολή <code>hello2.java</code></li>\r\n        <li>Στη συνέχεια εκτελούμε την εντολή <code>Java hello2</code>.</li>\r\n    </ol>\r\n</p>', 2),
(13, 'Μετατροπή τύπου δεδομένων (explicit casting)', 9, '', '<xmp>\r\nclass ShowCast1 {\r\n\r\n    public static void main(String args[]) {\r\n\r\n        double d1 = 3.2;\r\n        double d2 = 3.9999;\r\n        int iresult;\r\n\r\n        iresult = (int) d1;//το iresult ΄χει την τιμή 3 \r\n        System.out.println(iresult);\r\n\r\n        iresult = (int) d2;//το iresult ΄χει την τιμή 3 \r\n        System.out.println(iresult);\r\n\r\n        int i1 = 3;\r\n        int i2 = 6;\r\n        double dresult;\r\n\r\n        dresult = (double) i1 / (double) i2;  // το dresult έχει την τιμή 0.5 \r\n        System.out.println(dresult);\r\n\r\n        dresult = i1 / i2;  //το dresult έχει την τιμή 0 \r\n        System.out.println(dresult);\r\n    }\r\n}\r\n</xmp>\r\n\r\n<p>Βήματα\r\n    <ol>\r\n        <li>Δημιουργούμε τον κώδικα και τον ονομάζουμε\r\n            <file>ShowCast1.java</file>\r\n        </li>\r\n        <li>το μεταγλωττίζουμε μέσω της γραμμής εντολών με την εντολή <code>ShowCast1.java</code></li>\r\n        <li>Στη συνέχεια εκτελούμε την εντολή <code>Java ShowCast1</code>.</li>\r\n    </ol>\r\n</p>', 2),
(14, 'Μετατροπή τύπου δεδομένων (implicit casting)', 10, '', '<xmp>\r\nclass showCast2 {\r\n\r\n    public static void main(String args[]) {\r\n\r\n        int iresult, i1 = 3;\r\n        double dresult, d1 = 3.2;\r\n\r\n        dresult = i1 / d1;\r\n        iresult = i1 / (int) d1;\r\n\r\n        System.out.println(dresult);\r\n        System.out.println(iresult);\r\n    }\r\n}\r\n</xmp>\r\n<p>Βήματα\r\n    <ol>\r\n        <li>Δημιουργούμε τον κώδικα και τον ονομάζουμε\r\n            <file>showCast2.java</file>\r\n        </li>\r\n        <li>το μεταγλωττίζουμε μέσω της γραμμής εντολών με την εντολή <code>showCast2.java</code></li>\r\n        <li>Στη συνέχεια εκτελούμε την εντολή <code>Java showCast2</code>.</li>\r\n    </ol>\r\n</p>', 2),
(15, 'Μαθηματικές συναρτήσεις', 11, 'Να υπολογιστεί το εμβαδόν και η περιφέρεια ενός κύκλου όταν δίνεται  η ακτίνα του ', '<xmp>\r\npublic class cycle {\r\n\r\n    public static void main(String args[]) {\r\n\r\n        double radius = 15.0;\r\n        double area = 0.0;\r\n        double Circumference = 0.0;\r\n        long rArea, rCircumference;\r\n\r\n        area = Math.PI * Math.pow(radius, 2); //ypologismos tou emvadou \r\n        Circumference = 2 * Math.PI * radius;  //ypologismow tis perifereias \r\n\r\n        System.out.println(\"Area = \" + area);\r\n\r\n        rArea = (long) Math.round(area);\r\n\r\n        System.out.println(\"Area rounded = \" + rArea);\r\n        System.out.println(\"Circumference = \" + Circumference);\r\n\r\n        rCircumference = (long) Math.round(Circumference);\r\n        System.out.println(\"Circ/nce rounded= \" + rCircumference);\r\n    }\r\n}\r\n</xmp>\r\n\r\n<p>Βήματα\r\n    <ol>\r\n        <li>Δημιουργούμε τον κώδικα και τον ονομάζουμε\r\n            <file>cycle.java</file>\r\n        </li>\r\n        <li>το μεταγλωττίζουμε μέσω της γραμμής εντολών με την εντολή <code>cycle.java</code></li>\r\n        <li>Στη συνέχεια εκτελούμε την εντολή <code>Java cycle</code>.</li>\r\n    </ol>\r\n</p>', 2),
(16, 'Εισαγωγή δεδομένων από το πληκτρολόγιο', 12, 'Να δημιουργηθεί πρόγραμμα , που να δίνονται δύο αριθμοί από το πληκτρολόγιο και στη συνέχεια ο πρώτος να μετατρέπετε σε δεδομένα τύπου int, ενώ ο δεύτερος σε double. Στην συνέχεια το πρόγραμμα να βρίσκει και αν τυπώνει τα τετράγωνά τους.  ', '<xmp>\r\npublic class askisi2_5 {\r\n\r\n    public static void main(String[] args) {\r\n\r\n        int x1;\r\n        double x2;\r\n\r\n        x1 = Integer.valueOf(args[0]).intValue();\r\n        x1 = x1 * x1;\r\n\r\n        x2 = Double.valueOf(args[1]).doubleValue();\r\n        x2 = Math.pow(x2, 2);\r\n\r\n        System.out.println(\"x1*x1=\" + x1);\r\n        System.out.println(\"x2*x2=\" + x2);\r\n    }\r\n}\r\n</xmp>\r\n\r\n<p>Βήματα\r\n    <ol>\r\n        <li>Δημιουργούμε τον κώδικα και τον ονομάζουμε\r\n            <file>askisi2_5.java</file>\r\n        </li>\r\n        <li>το μεταγλωττίζουμε μέσω της γραμμής εντολών με την εντολή <code>askisi2_5.java</code></li>\r\n        <li>Στη συνέχεια εκτελούμε την εντολή <code>Java askisi2_5 7  3.5</code></li>\r\n    </ol>\r\n</p>\r\n\r\n<p>Εναλλακτικά μπορούμε να χρησιμοποιήσουμε την κλάση Scanner και να δώσουμε τις τιμές με την χρήση του πληκτρολογίου</p>\r\n<p>\r\nΘέλουμε να εισάγουμε δύο αριθμούς από το πληκτρολόγιο, ο πρώτος από αυτούς να είναι τύπου int και ο δεύτερος double. Και στις δύο περιπτώσεις θέλουμε η Java να υπολογίσει το τετράγωνό τους, στην πρώτη με τον απλό τρόπο και στην δεύτερη με την χρήση της συνάρτησης <code>Math.pow()</code>. Να σημειωθεί ότι η μέθοδος <code>print()</code> (σε αντίθεση με  την <code>println()</code>), τυπώνει τα δεδομένα στην κονσόλα χωρίς να αλλάζει γραμμή. \r\n</p>\r\n<xmp>\r\npackage showScanner; \r\nimport java.util.Scanner; \r\n\r\npublic class showScanner {\r\n\r\n    public static void main(String[] args) {\r\n\r\n        Scanner keyboard = new Scanner(System.in);\r\n\r\n        /* Με την παραπάνω δήλωση δημιουργείιται ένα αντικείμενο \r\n        της κλάσης Scanner και το αντικείμενο αυτό ονομάζεται keyboard*/\r\n        int x1;\r\n        double x2;\r\n\r\n        System.out.println();  //κενή γραμμή \r\n        System.out.println(\"x1=\");\r\n\r\n        x1 = keyboard.nextInt();\r\n\r\n        //εισαγωγή του πρώτου αριθμού ακεραίου \r\n        System.out.println();\r\n        System.out.println(\"x2=\");\r\n\r\n        x2 = keyboard.nextDouble();\r\n\r\n        //εισαγωγή του δεύτερου αριθμού διπλής ακρίβειας \r\n        System.out.println();\r\n\r\n        x1 = x1 * x1;\r\n        x2 = Math.pow(x2, 2);\r\n\r\n        System.out.println(\"x1*x1=\" + x1);\r\n        System.out.println(\"x2*x2=\" + x2);\r\n    }\r\n}\r\n</xmp>\r\n<p>Βήματα\r\n    <ol>\r\n        <li>Δημιουργούμε τον κώδικα και τον ονομάζουμε\r\n            <file>showScanner.java</file>\r\n        </li>\r\n        <li>το μεταγλωττίζουμε μέσω της γραμμής εντολών με την εντολή <code>showScanner.java</code></li>\r\n        <li>Στη συνέχεια εκτελούμε την εντολή <code>Java showScanner</code>.</li>\r\n    </ol>\r\n</p>', 2),
(17, 'Η κλάση Scanner', 13, '', '<xmp>\r\npublic class ShowScanner1 {\r\n\r\n    public static void main(String[] args) {\r\n\r\n        Scanner keyboard = new Scanner(System.in);\r\n\r\n        System.out.println();\r\n        System.out.println(\"Grapste ta grafeia kai tis karekles pou yparxoun\");\r\n\r\n        int grafeia = keyboard.nextInt();\r\n        int karekles = keyboard.nextInt();\r\n\r\n        System.out.println();\r\n        System.out.println(\"yparxoun \" + grafeia + \" grafeia kai \" + karekles + \" karekles\");\r\n    }\r\n}\r\n</xmp>\r\n<p>Βήματα\r\n    <ol>\r\n        <li>Δημιουργούμε τον κώδικα και τον ονομάζουμε\r\n            <file>ShowScanner1.java</file>\r\n        </li>\r\n        <li>το μεταγλωττίζουμε μέσω της γραμμής εντολών με την εντολή <code>ShowScanner1.java</code></li>\r\n        <li>Στη συνέχεια εκτελούμε την εντολή <code>Java ShowScanner1</code>.</li>\r\n    </ol>\r\n</p>', 2),
(18, 'Ο όρος else', 1, 'Να δημιουργηθεί ένα πρόγραμμα checkNum.java, το οποίο να παράγει έναν τυχαίο αριθμό από το ένα μέχρι το 10 και στη συνέχεια να εξετάζει αν ο αριθμός αυτός είναι άρτιος ή περιττός. Σε κάθε περίπτωση να τυπώνει το αντίστοιχο μήνυμα. ', '<img src=\"/letsLearnJava/images/artioi-perittoi.png\" />\r\n<xmp>\r\npublic class CheckNum {\r\n\r\n    public static void main(String[] args) {\r\n        int number = 0;\r\n        number = 1 + (int) (9 * Math.random());\r\n        if (number % 2 == 0) {\r\n            System.out.println(\"Number\" + number + \" is even\");\r\n        } else {\r\n            System.out.println(\"Number\" + number + \" is odd\");\r\n        }\r\n    }\r\n}\r\n</xmp>', 3),
(19, 'Ένθετα if', 2, '', '<xmp>\r\npublic class Order {\r\n\r\n    public static void main(String[] args) {\r\n        int x = -45, y = 115, z = 0;\r\n        \r\n        if (x < y && x < z) {\r\n            if (y < z) {\r\n                System.out.println(\"The order is\" + x + \",\" + y + \",\" + z);\r\n            } else {\r\n                System.out.println(\"The order is\" + x + \",\" + z + \",\" + y);\r\n            }\r\n        }\r\n        \r\n        if (x > z && x > y) {\r\n            if (x > z) {\r\n                System.out.println(\"The order is\" + y + \",\" + z + \",\" + x);\r\n            } else {\r\n                System.out.println(\"The order is\" + z + \",\" + y + \",\" + x);\r\n            }\r\n        }\r\n        \r\n        if (x < y && x > y) {\r\n            System.out.println(\"The order is\" + z + \",\" + x + \",\" + y);\r\n        }\r\n        if (x > y && x < z) {\r\n            System.out.println(\"The order is\" + y + \",\" + x + \",\" + z);\r\n        }\r\n    }\r\n}\r\n</xmp>\r\n<p>Η δομή διακλάδωσης περιέχει και τον όρο else if, άρα σχηματίζεται η δομή else…if   if…  . Παρακάτω γίνεται χρήση αυτής της δομή στο προηγούμενο παράδειγμα.  </p>\r\n<xmp>\r\npublic class Order1 {\r\n\r\n    public static void main(String[] args) {\r\n        int x = -45, y = 115, z = 0;\r\n        \r\n        if (x < y && x < z) {\r\n            if (y < z) {\r\n                System.out.println(\"The order is\" + x + \",\" + y + \",\" + z);\r\n            } else {\r\n                System.out.println(\"The order is\" + x + \",\" + z + \",\" + y);\r\n            }\r\n        } else if (x > z && x > y) {\r\n            if (z > y) {\r\n                System.out.println(\"The order is\" + y + \",\" + z + \",\" + x);\r\n            } else {\r\n                System.out.println(\"The order is\" + z + \",\" + y + \",\" + x);\r\n            }\r\n        } else if (x < y && x > z) {\r\n            System.out.println(\"The order is\" + z + \",\" + x + \",\" + y);\r\n        } else {\r\n            System.out.println(\"The order is\" + y + \",\" + x + \",\" + z);\r\n        }\r\n    }\r\n}\r\n</xmp>', 3),
(20, 'Ένθετα if 2', 3, 'Να δοθεί πλήρης λύση δευτεροβάθμιας εξίσωσης ax^2 + bx + c= 0. Τα δεδομένα a, b, c δίνονται κατά την εκτέλεση του προγράμματος. ', '<p>\r\nΓια να εισάγουμε από το πληκτρολόγιο δεδομένα που θέλουμε, πρέπει να δώσουμε τρία ορίσματα που θα αντιστοιχούν στους αριθμούς a, b, c. Τα ορίσματα αυτά αντιστοιχούν στα args[0] , args[1], args[2]. Τα δεδομένα του πληκτρολογίου είναι αλφαριθμητικά , άρα τα μετατρέπουμε και σε τύπο double όπως έχουμε μάθει σε προηγούμενο κεφάλαιο. \r\n</p>\r\n<xmp>\r\n    Double a=Double.valueOf(args[0]).doubleValue();\r\n    Double b=Double.valueOf(args[1]).doubleValue();\r\n    Double c=Double.valueOf(args[2]).doubleValue();\r\n</xmp>\r\n<p>\r\nΤο λογικό διάγραμμα για την λύση της δευτεροβάθμιας εξίσωσης είναι\r\n</p>\r\n<xmp>\r\npublic class eksiswsib {\r\n\r\n    public static void main(String[] args) {\r\n        double a = Double.valueOf(args[0]).doubleValue();\r\n        double b = Double.valueOf(args[1]).doubleValue();\r\n        double c = Double.valueOf(args[2]).doubleValue();\r\n        double d, x, x1, x2;\r\n        \r\n        if (a == 0.0) {\r\n            if (b == 0.0) {\r\n                if (c == 0.0) {\r\n                    System.out.println(\"Η εξίσωση είναι αόριστη\");\r\n                } else {\r\n                    System.out.println(\"Η εξίσωση είναι αδύνατη\");\r\n                }\r\n            } else {\r\n                x = -c / b;\r\n                System.out.println(\"Η λύση είναι\" + x);\r\n            }\r\n        } else {\r\n            d = b * b - 4 * a * c;\r\n            if (d > 0.0) {\r\n                x1 = (-b + Math.sqrt(d)) / (2 * a);\r\n                x2 = (-b - Math.sqrt(d)) / (2 * a);\r\n                System.out.println(\"Η εξίσωση έχει δύο πραγματικές ρίζες\");\r\n                System.out.println(\"x1 = \" + x1);\r\n                System.out.println(\"x2 = \" + x2);\r\n            } else if (d < 0.0) {\r\n                System.out.println(\"Η εξίσωση δεν έχει πραγματικές ρίζες\");\r\n            } else {\r\n                x = -b / (2 * a);\r\n                System.out.println(\"Η εξίσωση έχει διπλή ρίζα\");\r\n                System.out.println(\"x = \" + x);\r\n            }\r\n        }\r\n    }\r\n}\r\n</xmp>', 3),
(21, 'Ο τριαδικός τελεστής ?:', 4, 'Να κατασκευαστεί πρόγραμμα το οποίο να δημιουργεί δύο τυχαίους φυσικούς αριθμούς μικρότερους του 100 και στη συνέχεια να βρίσκει και αν εμφανίζει τον μεγαλύτερο και τον μικρότερο από αυτούς.', '<xmp>\r\npublic class Minmax {\r\n\r\n    public static void main(String[] args) {\r\n        int a = 1 + (int) (99 * Math.random());\r\n        System.out.println(\"The first is..\" + a);\r\n        \r\n        int b = 1 + (int) (99 * Math.random());\r\n        System.out.println(\"The first is..\" + b);\r\n        \r\n        int min = (a < b ? a : b);\r\n        int max = (a > b ? a : b);\r\n        \r\n        System.out.println(\"the minimum is...\" + min);\r\n        System.out.println(\"The maximum is...\" + max);\r\n    }\r\n}\r\n</xmp>', 3),
(22, 'Η δομή πολλαπλής διακλάδωσης switch', 5, 'Έστω ότι έχουμε μια τυχαία σειρά εμφάνισης αριθμού από το 1 έως το 5. Για τις τιμές 1 και 5 θέλουμε να τυπώσουμε τα χρώματα μαύρο και άσπρο αντίστοιχα, ενώ για τις τιμές 2, 3, 4 να τυπώσουμε τρία βασικά χρώματα (κόκκινο, πράσινο, μπλε) ', '<xmp>\r\npublic class showSwitch {\r\n\r\n    public static void main(String[] args) {\r\n        int x = (int) (1 + 5 * Math.random());\r\n        switch (x) {\r\n            case 1:\r\n                System.out.println(\"Black\");\r\n                break;\r\n            case 2:\r\n                System.out.println(\"Red\");\r\n                break;\r\n            case 3:\r\n                System.out.println(\"Green\");\r\n                break;\r\n            case 4:\r\n                System.out.println(\"Blue\");\r\n                break;\r\n            case 5:\r\n                System.out.println(\"White\");\r\n                break;\r\n        }\r\n    }\r\n}\r\n</xmp>', 3),
(23, 'Ο βρόγχος for', 6, 'Να γίνει πρόγραμμα το οποίο να δίνεται ο ακέραιος αριθμός Ν και στη συνέχεια να υπολογίζεται τα άθροισμα των αριθμών 1 + 2 + 3 + … + Ν.', '<p>\r\nΓια να λυθεί αυτό το πρόβλημα πρέπει να οριστεί μια μεταβλητή, έστω sum η οποία θα κρατά το άθροισμα των αριθμών και τις οποία δίνεται αρχική τιμή ίση με το 0. Δημιουργούμε στη συνέχεια ένα βρόγχο <code>for</code>, με το <code>i</code> να ξεκινά από το <code>1</code> και να αυξάνεται κατά <code>1</code> τελειώνοντας στο <code>Ν</code>. H εκάστοτε τιμή του <code>i</code> προστίθενται στη <code>sum</code>. Μόλις το <code>i</code> πάρει την τιμή <code>Ν</code> ο βρόγχος τελειώνει. \r\n</p>\r\n<xmp>\r\npublic class summation {\r\n\r\n    public static void main(String[] args) {\r\n        int N = 100;\r\n        int sum = 0;\r\n        for (int i = 1; i <= N; i++) {\r\n            sum = sum + i;\r\n            System.out.println(\"The sum is \" + sum);\r\n        }\r\n    }\r\n}\r\n</xmp>', 3),
(24, 'Ο βρόγχος while', 7, 'Να δημιουργηθεί ένα πρόγραμμα με όνομα halves.java το οποίο να δίνει σε μια μεταβλητή τύπου float την τιμή 10.0. Στη συνέχεια αυτή η μεταβλητή να υποδιπλασιάζεται μέχρι να γίνει μικρότερη από την τιμή 0.01.', '<xmp>\r\npublic class halves {\r\n\r\n    public static void main(String[] args) {\r\n        double x = 10.0;\r\n        System.out.println(\"Αρχική τιμή του x= \" + x);\r\n        while (x > 0.01) {\r\n            x /= 2;\r\n            System.out.println(\"το x έγινε: \" + x);\r\n        }\r\n    }\r\n}\r\n</xmp>', 3),
(25, 'Ο βρόγχος do-while', 8, 'Δίνεται ένας ακέραιος αριθμός Ν. Να υπολογιστεί το άθροισμα 1+2+3+….+Ν με την δομή do-while', '<xmp>\r\npublic class summation1 {\r\n\r\n    public static void main(String[] args) {\r\n        int N = 100;\r\n        int i = 1;\r\n        int sum = 0;\r\n        do {\r\n            sum += i++;\r\n        } while (i <= N);\r\n        System.out.println(\"The sum is\" + sum);\r\n    }\r\n}\r\n</xmp>', 3),
(26, 'Ένθετοι βρόγχοι', 9, 'Προπαίδεια ', '<xmp>\r\npublic class propaidia {\r\n\r\n    public static void main(String[] args) {\r\n        int c = 0;\r\n        for (int a = 1; a <= 10; a++) {\r\n            for (int b = 1; b <= 10; b++) {\r\n                c = a * b;\r\n                System.out.println(a + \"x\" + b + \"=\" + c);\r\n            }\r\n            System.out.println();\r\n        }\r\n    }\r\n}\r\n</xmp>', 3),
(27, 'Η εντολή continue', 10, 'Να υπολογιστεί το παραγοντικό των αριθμών από το 1 μέχρι το 20 εκτός των αριθμών 5 και 15', '<xmp>\r\npublic class showcontinue1 {\r\n\r\n    public static void main(String[] args) {\r\n        int ubound = 20; //άνω ότιο το 20\r\n        long fact = 1;\r\n        /* αρχική τιμή στο fact */\r\n\r\n        label1:\r\n        for (int i = 1; i <= ubound; i++) {\r\n            fact = 1;\r\n            for (int j = 2; j <= i; j++) {\r\n                if (i == 5 | i == 15) {\r\n                    continue label1;\r\n                }\r\n                fact *= j;\r\n            }\r\n            System.out.println(i + \" ! \" + \" is \" + fact);\r\n        }\r\n    }\r\n}\r\n</xmp>', 3),
(28, 'Μέθοδοι', 11, 'Να δημιουργηθεί πρόγραμμα με την ονομασία showMethod.java όπου μέσα σε αυτό να δημιουργηθεί η μέθοδος cube(), η οποία να βρίσκει τον κύβο ενός ακέραιου αριθμού. Το κυρίως πρόγραμμα να καλεί 10 φορές την μέθοδο cube() και να βρίσκει και να τυπώνει τους κύβους των αριθμών από το 0 έως το 9. ', '<xmp>\r\npublic class showMethod {\r\n\r\n    public static void main(String[] args) {\r\n        for (int i = 0; i < 10; i++) {\r\n            System.out.println(i + \"	\" + cube(i));\r\n        }\r\n    }\r\n\r\n    static int cube(int n) {\r\n        return n * n * n;\r\n    }\r\n}\r\n</xmp>\r\n', 3);
INSERT INTO `exercise` (`id`, `title`, `ordering`, `description`, `solution`, `level_id`) VALUES
(29, 'Μέθοδοι 2', 12, 'Να δημιουργηθεί συνάρτηση η οποία να δέχεται έναν αριθμό και αν επιστρέφει τον παραγοντικό του. Να τυπωθούν τα παραγοντικά για του αριθμούς από 0 έως 9.', '<xmp>\r\npublic class showLocal {\r\n\r\n    public static void main(String[] args) {\r\n        for (int i = 0; i < 9; i++) {\r\n            System.out.println(\"factorial(\" + i + \")= \" + factorial(i));\r\n        }\r\n    }\r\n\r\n    static long factorial(int n) {\r\n        long f = 1;\r\n        while (n > 1) {\r\n            f *= n--;\r\n        }\r\n        return f;\r\n    }\r\n}\r\n</xmp>\r\n<p>\r\nΣτο κυρίως πρόγραμμα ο βρόγχος <code>for</code> καλεί εννέα φορές τη μέθοδο <code>factorial()</code>. Όταν ο μετρητής <code>i</code> είναι μια τιμή, η κλήση της <code>factorial(i)</code> στέλνει το <code>i</code> ως όρισμα στην τιμή της παραμέτρου ή της συνάρτησης. Μέσα σε μια μέθοδο <code>factorial()</code>, η τοπική μεταβλητή <code>f</code>  παίρνει αρχική τιμή 1 και στη συνέχεια πολλαπλασιάζεται διαδοχικά με όλο και μικρότερες τιμές του <code>n</code> μέχρι  το <code>n</code> να φτάσει στην τιμή 1. Στην τιμή αυτή ο βρόγχος <code>while</code> σταματάει και επιστρέφει την τελική τιμή της <code>factorial</code> για να εκτυπωθεί. \r\n</p>\r\n<p>\r\nΜια ειδική περίπτωση μεθόδου είναι η αναδρομική μέθοδος. Αναδρομική (recursive) λέγετε η μέθοδος που καλεί τον εαυτό της.\r\n</p>\r\n<p>Για να δούμε την λειτουργία της αναδρομικής μεθόδου, θα υπολογίσουμε ο παραγοντικό των αριθμών από 0 έως 9, κάνοντας χρήσης της (αναδρομικής) μεθόδου <code>factorial</code>. </p>\r\n<xmp>\r\npublic class showRecursion {\r\n\r\n    public static void main(String[] args) {\r\n        for (int i = 0; i < 9; i++) {\r\n            System.out.println(\"factorial(\" + i + \") = \" + factorial(i));\r\n        }\r\n    }\r\n\r\n    static long factorial(int n) {\r\n        if (n < 2) {\r\n            return 1;\r\n        }\r\n        return n * factorial(n - 1);\r\n    }\r\n}\r\n</xmp>\r\n', 3),
(34, 'Δημιουργία των δικών μας εξαιρέσεων', 1, 'Να γίνει δημιουργία ενός applet με τρία πεδία κειμένου. Στα δύο πρώτα θα γίνεται εισαγωγή ακεραίων αριθμών και στο τρίτο θα εμφανίζεται το πηλίκο της διαίρεσης τους. Να δημιουργηθεί κώδικας ο οποίος θα συλλαμβάνει και θα χειρίζεται την εξαίρεση της διαίρεσης ακέραιου με το μηδέν και το σφάλμα που προκύπτει να δεν δοθούν ακέραιοι σαν δεδομένα.  ', '<p>Αρχικά δημιουργείται το πρόγραμμα <code>showException.java</code></p>\r\n<xmp>\r\npackage showexception;\r\n\r\nimport java.applet.*;\r\nimport java.awt.*;\r\nimport java.awt.event.*;\r\nimport java.text.DecimalFormat;\r\n\r\npublic class ShowException extends Applet implements ActionListener {\r\n\r\n    Label l1, l2, l3;\r\n    TextField t1, t2;\r\n    int n1, n2;\r\n    double result;\r\n    DecimalFormat precision2;\r\n\r\n    String s = \"\", s1 = \"\";\r\n\r\n    public void init() {\r\n\r\n        l1 = new Label(\"Διαιρετέος\");\r\n        add(l1);\r\n\r\n        t1 = new TextField(10);\r\n        add(t1);\r\n\r\n        l2 = new Label(\"Διαιρέτης\");\r\n        add(l2);\r\n\r\n        t2 = new TextField(10);\r\n        t2.addActionListener(this);\r\n        add(t2);\r\n    }\r\n\r\n    public void paint(Graphics g) {\r\n        g.drawString(s, 40, 100);\r\n        g.drawString(s1, 40, 120);\r\n    }\r\n\r\n    public void actionPerformed(ActionEvent e) {\r\n\r\n        precision2 = new DecimalFormat(\"#.00\");\r\n\r\n        try {\r\n\r\n            n1 = Integer.parseInt(t1.getText());\r\n            n2 = Integer.parseInt(t2.getText());\r\n\r\n            result = quot(n1, n2);\r\n\r\n            s = \"Το αποτέλεσμα είναι:\";\r\n\r\n            s1 = precision2.format(result).toString();\r\n\r\n            t1.setText(\"\");\r\n            t2.setText(\"\");\r\n\r\n            repaint();\r\n\r\n        } catch (NumberFormatException nfe) {\r\n            showStatus(\"Πρέπει να βάλετε δύο ακέραιους αριθμούς\");\r\n        } catch (ZeroDivideException zde) {\r\n\r\n            s = \"Αδύνατη πράξη\";\r\n            s1 = \"Διαίρεση με το μηδέν\";\r\n\r\n            repaint();\r\n            showStatus(zde.toString());\r\n        }\r\n    }\r\n\r\n    public double quot(int firstnum, int secondnum)\r\n            throws ZeroDivideException {\r\n        if (secondnum == 0) {\r\n            throw new ZeroDivideException();\r\n        }\r\n        return (double) firstnum / secondnum;\r\n    }\r\n\r\n    public class ZeroDivideException extends ArithmeticException {\r\n\r\n        public ZeroDivideException() {\r\n            super(\"Σφάλμα! Διαίρεση με το μηδέν\");\r\n        }\r\n    }\r\n}\r\n</xmp>\r\n<p>Ανάλυση παραδείγματος</p>\r\n<p>Κοιτώντας το πρόγραμμα από κάτω προς τα πάνω παρατηρούμε μια εξαίρεση την κλάση <code>ZeroDivideException</code> η οποία επεκτείνει την <code>ArithmeticException</code>. Σε αυτό το κομμάτι όταν προσπαθεί να διαιρεθεί με τον μηδέν κάποιος αριθμός εμφανίζεται το μήνυμα «Σφάλμα! Διαίρεση με το μηδέν».  </p>\r\n<p>\r\nΠάνω από αυτή την εξαίρεση υπάρχει η μέθοδος <code>quot()</code>, που υπολογίζει το πηλίκο της διαίρεσης δύο αριθμών. Μέσα στην μέθοδο <code>quot()</code> γίνεται χρήση της λέξης <code>throws</code>, ώστε να μπορεί να παραχθεί μια εξαίρεση τύπου <code>ZeroDivideException</code> όταν ο δεύτερος αριθμός είναι μηδέν.  \r\n</p>\r\n<p>Αρκετά ψηλά στο πρόγραμμα υπάρχει η μέθοδος <code>init()</code>, στην οποία ορίζονται δύο ετικέτες και δύο πλαίσια κειμένου, για να μπορεί το πρόγραμμα να δεχθεί δύο ακεραίους και να τους διαιρέσει μετά. Στο δεύτερο πεδίο (εκεί θα μπει ο διαιρέτης) καταχωρείται ακροατής με την δήλωση <code>t2.addActionListener(this);</code> \r\n</p>\r\n<p>\r\nΈτσι μόλις πατηθεί enter, ξεκινάει η διαδικασία της διαίρεσης.  Στη συνέχεια υπάρχει μια μέθοδος , η <code>paint()</code> στην οποία τυπώνονται τα αλφαριθμητικά <code>s</code> και <code>s1</code>.\r\n</p>\r\n<p>Μέσω της δήλωσης <code>precision2 = new DecimalFormat(\"#.00\"); </code>, δημιουργείται ένα αντικείμενο της κλάσης DecimalFormat, το οποίο γίνεται εισαγωγή στην αρχή του προγράμματος, (<code>importjava.text.DecimalFormat;</code>). Το <code>precision2</code> χρησιμοποιείται ώστε το πηλίκο της διαίρεσης να εμφανίζεται με ακρίβεια δύο δεκαδικών ψηφίων.  </p>\r\n<p>Μετά από αυτά υπάρχει το <code>try</code> το οποίο έχει το <code>result=quot(n1,n2);</code> το οποίο αν χρειαστεί δημιουργεί εξαίρεση.</p>\r\n<p>Το πρώτο <code>catch (NumberFormatException nfe)</code> ενεργοποιείται αν ο χρήστης δεν βάλει ακέραιους αριθμού και δημιουργεί εξαίρεση. Το δεύτερο <code>catch (ZeroDivideException zde)</code> ενεργοποιείται αν γίνει εξαίρεση με το μηδέν.  \r\n</p>', 15),
(35, 'Ισχυρισμοί', 2, 'Να βρεθεί η τετραγωνική ρίζα της απόστασης δύο αριθμών. Να δημιουργηθεί ένας ισχυρισμός για την διαφορά τους που  θα πρέπει να είναι μεγαλύτερη ή ίση του 0.  ', '<xmp>\r\nimport javax.swing.JOptionPane; \r\n\r\n \r\npublic class showAssertion2 {\r\n\r\n    public static void main(String args[]) {\r\n\r\n        String snum1, snum2;\r\n        int num1, num2, diff;\r\n\r\n        snum1 = JOptionPane.showInputDialog(\"Dwste ton prwto arithmo\");\r\n        snum2 = JOptionPane.showInputDialog(\"Dwse ton deutero arithmo\");\r\n\r\n        num1 = Integer.parseInt(snum1);\r\n        num2 = Integer.parseInt(snum2);\r\n\r\n        diff = num1 - num2;\r\n        assert diff >= 0 : \"i yporizi posotita einai arnitiki\";\r\n\r\n        JOptionPane.showMessageDialog(null, \"H tetragwniki riza tis apostasis tous einai:\" + Math.sqrt(diff), \"Tetagwniki riza\", JOptionPane.PLAIN_MESSAGE);\r\n\r\n        System.exit(0);\r\n    }\r\n}\r\n</xmp>\r\n<p>Μεταγλωττίζουμε το πρόγραμμα και το εκτελούμε</p>\r\n<p><code>Javac -source 1.6 showAssertion2.java </code></p>\r\n<p><code>Java -ea showAssertion2 </code></p>\r\n<p>Αν ο πρώτος αριθμός είναι ίσος/μεγαλύτερος από τον δεύτερο, το πρόγραμμα θα εκτελεστεί φέρνοντας την τετραγωνική ρίζα. Αν ο δεύτερος αριθμός είναι μεγαλύτερος, εμφανίζεται το  μήνυμα: \r\n</p>\r\n<p><code>\r\nException in thread “main” java.lang.AssertionError:H yporizi posotita einai anrnitiki at showAssertions2.main(showAssertions2.java:17) </code>\r\n</p>\r\n<p>Η διόρθωση του κώδικα γίνεται ως εξής </p>\r\n<p><code>diff= Math.abs(num1-num2); </code></p>', 15),
(36, 'Δημιουργία νήματος με την κλάση Thread', 1, 'Να κατασκευαστεί πρόγραμμα, στο οποίο θα δημιουργούνται τρία νήματα. Κάθε νήμα πρέπει να καθυστερεί τυχαίο χρονικό διάστημα μεταξύ 0 και 1 δευτερολέπτου. Κατά την έξοδο να τυπώνεται η καθυστέρηση που προέκυψε για κάθε νήμα καθώς και η σειρά των νημάτων. ', '<xmp>\r\npublic class showThread {\r\n\r\n    public static void main(String[] args) {\r\n\r\n        MyThread threads[];\r\n        int size = 3;\r\n        threads = new MyThread[size];\r\n        String str;\r\n\r\n        for (int i = 0; i <= 3; i++) {\r\n\r\n            str = String.valueOf(i + 1);\r\n            threads[i] = new MyThread(str);\r\n            threads[i].start();\r\n\r\n        }\r\n    }\r\n}\r\n</xmp>', 16);

-- --------------------------------------------------------

--
-- Table structure for table `level`
--

DROP TABLE IF EXISTS `level`;
CREATE TABLE IF NOT EXISTS `level` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `title` varchar(50) COLLATE utf8_bin NOT NULL,
  `ordering` int(11) NOT NULL,
  `published` tinyint(1) NOT NULL,
  PRIMARY KEY (`id`)
) ENGINE=MyISAM AUTO_INCREMENT=17 DEFAULT CHARSET=utf8 COLLATE=utf8_bin;

--
-- Dumping data for table `level`
--

INSERT INTO `level` (`id`, `title`, `ordering`, `published`) VALUES
(1, 'Level 1', 1, 1),
(2, 'Level 2', 2, 1),
(3, 'Level 3', 3, 1),
(4, 'Level 4', 4, 1),
(5, 'Level 5', 5, 1),
(16, 'Level 7', 7, 1),
(15, 'Level 6', 6, 1);

-- --------------------------------------------------------

--
-- Table structure for table `lookup`
--

DROP TABLE IF EXISTS `lookup`;
CREATE TABLE IF NOT EXISTS `lookup` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `grouping` varchar(50) COLLATE utf8_bin NOT NULL,
  `description` varchar(1500) COLLATE utf8_bin NOT NULL,
  PRIMARY KEY (`id`)
) ENGINE=MyISAM AUTO_INCREMENT=6 DEFAULT CHARSET=utf8 COLLATE=utf8_bin;

--
-- Dumping data for table `lookup`
--

INSERT INTO `lookup` (`id`, `grouping`, `description`) VALUES
(1, 'users', 'admin'),
(2, 'users', 'simple user'),
(3, 'question_type', 'Συμπλήρωσης κενού'),
(4, 'question_type', 'Πολλαπλής επιλογής'),
(5, 'question_type', 'Σωστό/λάθος');

-- --------------------------------------------------------

--
-- Table structure for table `question`
--

DROP TABLE IF EXISTS `question`;
CREATE TABLE IF NOT EXISTS `question` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `description` varchar(1500) COLLATE utf8_bin NOT NULL,
  `ordering` int(11) NOT NULL,
  `level_id` int(11) NOT NULL,
  `type_id` int(11) NOT NULL,
  PRIMARY KEY (`id`),
  KEY `level_id` (`level_id`),
  KEY `type_id` (`type_id`)
) ENGINE=MyISAM AUTO_INCREMENT=47 DEFAULT CHARSET=utf8 COLLATE=utf8_bin;

--
-- Dumping data for table `question`
--

INSERT INTO `question` (`id`, `description`, `ordering`, `level_id`, `type_id`) VALUES
(1, 'Για να εκτελεστεί ένα applet χρειάζεται', 1, 1, 4),
(2, 'Ένα αρχείο πηγαίου κώδικα έχει αποθηκευτεί με το όνομα hello.java . Το όνομα αυτό υπάρχει και μέσα στον πηγαίο κώδικα κατά τον ορισμό της βασικής κλάσης. Αν μετονομάσουμε το αρχείο σε Hello.java(με κεφαλαίο), δεν θα υπάρξει κανένα πρόβλημα', 2, 1, 5),
(3, 'Τι πρέπει να προσέχουμε όταν μια γλώσσα είναι case sensitive', 3, 1, 3),
(15, 'Να τροποποιηθεί η εφαρμογή η οποία τυπώνει την φράση \"Hello World!!!\" έτσι ώστε να τυπώνει σε δύο σειρές τις φράσεις\r\n<xmp>\r\nHello World!!!\r\nI am Kostas.\r\n</xmp>', 4, 1, 4),
(10, 'Μετά τις δηλώσεις των παρακάτω μεταβλητών, η τιμή της numBooks έχει την τιμή 0\r\n<xmp>int numStudents, numBooks, numTeachers = 50; </xmp>', 1, 2, 5),
(23, 'Να αναφέρετε 5 εντολές με τις οποίες μπορούμε να ελέγξουμε την ροή ενός προγράμματος', 1, 3, 3),
(12, 'Σε έναν πίνακα που περιέχει 40 ακεραίους η μεγαλύτερη τιμή του δείκτη είναι το 40', 1, 4, 5),
(31, 'Για να επιστραφεί μια τιμή ως αποτέλεσμα μιας μεθόδου χρησιμοποιείται η λέξη ', 1, 5, 4),
(14, 'Οι εξαιρέσεις της Java κληρονομούνται από την κλάση ', 1, 15, 4),
(16, 'Το όνομα μιας μεταβήτής μπορεί να αρχίζει από ', 2, 2, 3),
(17, 'Με ποιόν από τους παρακάτω συμβολισμούς μπορεί να αρχίζει ένα σχόλιο;', 3, 2, 4),
(18, 'Ποιά θα είναι η τιμή της μεταβλητής z μετά την εκτέλεση του παρακάτω κώδικα\r\n<xmp>\r\nint z = 100;\r\n++z;\r\n</xmp>', 4, 2, 3),
(19, 'Το αποτέλεσμα της πράξης 14 % 5 είναι 2', 5, 2, 5),
(20, 'Ποιές θα είναι οι τιμές των μεταβλητών x, a, b μετά την εκτέλεση του παρακάτω  κώδικα\r\n<xmp>\r\nint x, a=10, b=11;\r\nx=a++ + b++;\r\n</xmp>', 6, 2, 4),
(21, 'Το αποτέλεσμα της πράξης <code> (10 == 6 + 4) && (5<7)</code> είναι true', 7, 2, 5),
(22, 'Το αποτέλεσμα της πράξης <code>(5 < 7) || (10 == 11) ||  (3 != 3) </code> είναι true', 8, 2, 5),
(24, 'Μπορούμε να υλοποιήσουμε μια δομή switch χρησιμοποιώντας πολλαπλά if', 2, 3, 5),
(25, 'Το αποτέλεσμα του επόμενου κώδικα θα είναι \r\n<xmp> \r\nfor(int j=1; j<=48; j=j*2)\r\n    System.out.println(j);\r\n</xmp>', 3, 3, 4),
(26, 'Ποιά από τις παρακάτω εντολές θα χρησιμοποιήσουμε σε έναν βρόγχο for, do_while ή while προκειμένου να βγούμε από αυτόν και να συνεχίσουμε με τις επόμενες εντολές του προγράμματος;', 4, 3, 4),
(27, 'Ποιά από τις παρακάτω εντολές θα χρησιμοποιήσουμε σε έναν βρόγχο for, do_while ή while όταν θέλουμε να βγούμε από το υπόλοιπο του προγράμματος που βρίσκεται μέσα στο σώμα του βρόγχου, αλλά να συνεχίσουμε με την επόμενη επανάληψη του ίδιου βρόγχου.', 5, 3, 4),
(28, 'Ο παρακάτω βρόγχος θα εκτελεστεί  ακριβώς 3 φορές;\r\n<xmp>\r\nint count = 0;\r\nfor (int i = 3; i < 12; i += 2) {\r\n    ++count;\r\n    System.out.println(count);\r\n }\r\n</xmp>', 6, 3, 5),
(29, 'Ποιά θα είναι η τιμή που θα εκτυυπωθεί μετά την εκτέλεση του παρακάτω κώδικα\r\n<xmp>\r\n int[] val = new int[5];\r\n        val[0] = 7;\r\nval[1] = 3;\r\nval[2] = 4;\r\nval[3] = 1;\r\nval[4] = 9;\r\nSystem.out.println(val[2 + 1]);\r\n</xmp>', 2, 4, 4),
(30, 'Αφού κάνουμε την δήλωση <code>String[ ] str1 = new String[10]; </code> η τιμή του str1[4]  είναι Null', 3, 4, 5),
(32, 'Μια κλάση μπορεί να έχει πάνω από έναν κατασκευαστή', 2, 5, 5),
(33, 'Η ενθυλάκωση παρουσιάζει την εξωτερική όψη ενός αντικειμένου και αποκρύπτει την πολύπλοκή λογική του', 3, 5, 5),
(34, 'Έστω ότι έχουμε τις παρακάτω μεθόδους \r\n<xmp>\r\npublic static double add(int a, int b) {\r\n    return a + b;\r\n}\r\npublic static double add(double a, double b) {\r\n    return a + b;\r\n}\r\n</xmp> \r\nαποτελεί  ', 4, 5, 4),
(35, 'Η λέξη <code>super</code> χρησιμεύει στην κλήση των μελών της υποκλάσης μια κλάσης', 5, 5, 5),
(36, 'Προκειμένου να μην επιτρέψουμε την δημιουργία υποκλάσης μιας κλάσης χρησιμοποιώ την λέξη ', 6, 5, 3),
(37, 'Για να ορίσουμε ότι μια κλάση υλοποιεί ένα interface χρησιμοποιούμε την λέξη ', 7, 5, 4),
(38, 'Για να συλληφθεί μια εξαίρεση ο κώδικας που πρέπει να την προκαλέσει περικλείεται σε ένα τμήμα catch ', 2, 15, 5),
(39, 'Σε ένα κομμάτι κώδικα το τμήμα finally θα εκτελεστεί μόνο στην περίπτωση που συλληφθεί μια εξαίρεση', 3, 15, 5),
(40, 'Σε ένα block try μπορεί  να υπάρχουν πάνω από ένα catch και πάνω από ένα finally', 4, 15, 5),
(41, 'Τι εξαίρεση θα δημιουργηθεί αν προσπαθήσουμε να εισάγουμε ένα δεκαδικό σε μια μεταβλητή ακεραίου', 5, 15, 4),
(42, 'Χρησιμοποιούμε την μέθοδο start για να εκτελέσουμε ένα νήμα και με αυτόν τον τρόπο καταχωρίζεται στον χρονοπρογραμματιστή νήματος', 1, 16, 5),
(43, 'Χρησιμοποιούμε την μέθοδο sleep για να εκτελέσουμε ένα νήμα μετά από x χρονικό διάστημα. Μετά από αυτόν το χρόνο θα καταχρηθεί στον χρονοπρογραμματιστή νήματος', 2, 16, 5),
(44, 'Τα νήματα δαίμονα είναι συγκεκριμένες κλάσεις στην java οι οποίες δεν μπορούνε να οριστούνε από έναν προγραμματιστή', 3, 16, 5),
(45, 'Η μέθοδος isDaemon χρησιμοποιείται προκειμένου να επιβεβαιώσουμε ότι ένα νήμα είναι δαίμονας ή όχι', 4, 16, 5),
(46, 'Ένα νήμα πρέπει να περιέχει πάντα την μέθοδο run η οποία είναι public δεν πέρνει ορίσματα και δεν επιστρέφει κάτι', 5, 16, 5);

-- --------------------------------------------------------

--
-- Table structure for table `theory`
--

DROP TABLE IF EXISTS `theory`;
CREATE TABLE IF NOT EXISTS `theory` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `title` varchar(50) COLLATE utf8_bin NOT NULL,
  `description` longtext COLLATE utf8_bin NOT NULL,
  `downloadFile` blob DEFAULT NULL,
  `level_id` int(11) NOT NULL,
  PRIMARY KEY (`id`),
  KEY `level_id` (`level_id`)
) ENGINE=MyISAM AUTO_INCREMENT=14 DEFAULT CHARSET=utf8 COLLATE=utf8_bin;

--
-- Dumping data for table `theory`
--

INSERT INTO `theory` (`id`, `title`, `description`, `downloadFile`, `level_id`) VALUES
(1, 'Εισαγωγή', '<h3>\r\n    Ξεκίνημα με την Java\r\n</h3>\r\n<p>\r\n    Τα προγράμματα περιήγησης της IE, Mozilla Firefox, Google Chrome, μας επιτρέπουν να εκτελέσουμε\r\n    applet της Java όμως δεν μας επιτρέπουν να γράψουμε κώδικα Java. Για να μπορέσουμε να γράψουμε κώδικα\r\n    Java θα χρειαστούμε ειδικό πακέτο ανάπτυξης εφαρμογών το JDK (Java Development Kit), το οποίο περιέχει\r\n    μια ομάδα από εργαλεία όπως μεταγλωττιστής, διερμηνευτής, αποσφαλματωτής (debugger), αποσυμβολομεταφραστής\r\n    (disassembler) κ.α. Μπορούμε να κατεβάσουμε τα ανωτέρω εργαλεία δωρεάν από την σελίδα της <a\r\n        href=\"http://java.sun.com/\" target=\"_blank\">Sun</a>\r\n    για την Java.\r\n</p>\r\n<p>\r\n    Πατώντας τον σύνδεσμο πηγαίνουμε στην ιστοσελίδα όπου από εκεί κατεβάζουμε το JDK και το κάνουμε εγκατάσταση\r\n    στον υπολογιστή μας, Το JDK είναι το μόνο πρόγραμμα που είναι απαραίτητο για την συγγραφή κώδικα Java.\r\n    Το μειονέκτημά του είναι ότι δεν είναι και το πιο εύκολο πρόγραμμα για την γραφή κώδικα και έτσι υπάρχουν\r\n    στο διαδίκτυο προϊόντα από τρίτους κατασκευαστές τα οποία λέγονται ενοποιημένα περιβάλλοντα ανάπτυξης\r\n    (Integrated Development Environments IDE) και μας βοηθάνε να γράψουμε εύκολα εφαρμογές σε Java. Μερικά από\r\n    αυτά τα προγράμματα είναι:\r\n<ul>\r\n    <li>\r\n        <a href=\"www.netbeans.org\" target=\"_blank\">το NetBeans</a>\r\n    </li>\r\n    <li>\r\n        <a href=\"www.eclipse.orge\" target=\"_blank\">το Eclipse</a>\r\n    </li>\r\n    <li>\r\n        <a href=\"http://www.codegear.com/products/jbuider\" target=\"_blank\">ο JBuilder της\r\n            εταιρίας Borland</a>\r\n    </li>\r\n</ul>\r\n</p>\r\n<p>\r\n    Το αρχείο το οποίο περιέχει το JDK είναι αυτοσυμπιεζόμενο (αποσυμπιέζεται και εγκαθίσταται μόνο του) όταν το\r\n    διπλοπατήσουμε. Η εγκατάσταση γίνεται συνήθως μέσα στο Program Files στον υποφάκελο Java.\r\n<ul>\r\n    <li>\r\n        Εντός του φακέλου Java υπάρχει ο υποφάκελος <b>bin</b> όπου σε αυτόν υπάρχουν εργαλεία ανάπτυξης όπως ο\r\n        μεταγλωττιστής, ο διερμηνευτής, ο αποσφαλματωτής και πολλά άλλα.\r\n    </li>\r\n    <li>\r\n        Στο φάκελο demo βρίσκονται αρκετά έτοιμα applet, τα οποία μπορούμε να εκτελέσουμε για να δούμε πως λειτουργούν\r\n        και να μελετήσουμε τον κώδικά τους.\r\n    </li>\r\n    <li>\r\n        Ο υποκατάλογος <b>lib</b> έχει μέσα αρχεία βιβλιοθήκης της γλώσσας.\r\n    </li>\r\n</ul>\r\n\r\n</p>\r\n<p>\r\n    Για να μπορούμε να χρησιμοποιήσουμε τα εργαλεία της Java σε όποιο φάκελο βρισκόμαστε πρέπει να τοποθετήσουμε τον\r\n    φάκελο bin στη μεταβλητή περιβάλλοντος PATH. H ρύθμιση αυτή γίνεται με διαφορετικό τρόπο για κάθε λειτουργικό\r\n    σύστημα.\r\n</p>\r\n<p>\r\n    Για Windows 7 και Windows 10 πηγαίνουμε στο εικονίδιο ο Υπολογιστής μου ή This PC (Windows 10) και μετά με\r\n    το δεξί κλικ properties. Στη συνέχεια κλικάρουμε την επιλογή Advanced System Settings. Μόλις την ανοίξουμε\r\n    εμφανίζεται η καρτέλα System Properties, από εκεί πηγαίνουμε στο Advanced και στη συνέχεια στο Enviroment Variables.\r\n    Στις System variables βρίσκουμε την PATH και αν δεν υπάρχει προσθέτουμε το Path που βρίσκεται το Bin από την\r\n    εγκατάσταση του JDK. D:\\Java\\jdk1.8.0_241\\bin; (Ανάλογα με την έκδοση της Java και το που την έχουμε\r\n    εγκαταστήσει)\r\n</p>\r\n\r\n<h3>\r\n    Το περιβάλλον την Java\r\n</h3>\r\n<p>\r\n    Η Java σαν γλώσσα προγραμματισμού μπορεί να δημιουργήσει προγράμματα τα οποία τρέχουν σε διάφορους υπολογιστές και\r\n    λειτουργικά συστήματα. Αυτό το διαπιστώνουμε αν δούμε πως λειτουργεί ο μεταγλωττιστής σε μια παραδοσιακή γλώσσα και\r\n    πως λειτουργεί ο μεταγλωττιστής της Java.\r\n</p>\r\n<p>\r\n    Σε μια παραδοσιακή γλώσσα όπως για παράδειγμα Pascal, C κ.α. ο μεταγλωττιστής μετατρέπει το πρόγραμμα που έχουμε\r\n    γράψει (source code) σε δυαδικό αρχείο (binary file), σε κώδικα γλώσσας μηχανής κατάλληλο για τον επεξεργαστή.\r\n</p>\r\n<p>\r\n    Η Java λειτουργεί διαφορετικά. Το περιβάλλον ανάπτυξής της έχει δύο κομμάτια:\r\n<ol>\r\n    <li>\r\n        Το μεταγλωττιστή, ο οποίος αντί για δυαδικό αρχείο δημιουργεί ένα κώδικα byte που είναι ανεξάρτητος από την\r\n        πλατφόρμα.\r\n    </li>\r\n    <li>\r\n        Το διερμηνευτή κώδικα byte (προσαρμοσμένο σε κάθε πλατφόρμα), ο οποίος ονομάζεται και εικονική μηχανή Java (Java\r\n        Virtual Machine, JVM) ή Διερμηνευτής java Χρόνου εκτέλεσης (Java Runtime Interpreter). Ο διερμηνευτής διαβάζει\r\n        τον κώδικα byte και εκτελεί τις κατάλληλες εντολές που αντιστοιχούν στον εκάστοτε επεξεργαστή.\r\n    </li>\r\n</ol>\r\n</p>\r\n<p>\r\n    Τα πιο συνηθισμένα προγράμματα πλοήγησης στο Internet περιέχουν τον Διερμηνευτή κώδικα byte (Java Virtual Machine).\r\n    Μόλις λοιπόν φορτώσουν μια σελίδα από τον internet, αυτόματα κατεβάζουν τον κώδικα της Java από την περιοχή της\r\n    σελίδας που τον περιέχει και τρέχουν την JVM πάνω σε αυτόν. Με αυτό τον τρόπο επιτυγχάνεται η παρουσίαση κινούμενων\r\n    εικόνων, μουσικής, φορμών εισαγωγής κ.α. τα οποία είναι γραμμένα σε Java και περιέχονται στη σελίδα.\r\n</p>', NULL, 1),
(2, 'Δεδομένα, μεταβλητές και υπολογισμοί', '<h3>\r\n    Μεταβλητές και Δεδομένα\r\n</h3>\r\n<div>\r\n    <p>\r\n        Με τον όρο μεταβλητή (variable) στην java εννοούμε μια περιοχή της μνήμης στην οποία έχουμε δώσει ένα όνομα και την χρησιμοποιούμε για την αποθήκευση δεδομένων. Κάθε τέτοια μεταβλητή κρατάει δεδομένα ενός συγκεκριμένου τύπου. Αφού καθορίσουμε τον τύπο\r\n        των δεδομένων της μεταβλητής, ο μεταγλωττιστής έχει την δυνατότητα να ελέγχει όσα δεδομένα περνάνε από αυτή. Πριν κάνουμε χρήση μιας μεταβλητής, θα πρέπει να δηλώσουμε τον τύπο της και το όνομά της. Συνήθως τις μεταβλητές τις δηλώνουμε στην αρχή\r\n        του προγράμματος, χωρίς να είναι λάθος να δηλωθεί μια μεταβλητή και σε κάποιο άλλο σημείο του προγράμματος. Το όνομα που επιλέγουμε για μια μεταβλητή στην java λέγετε αναγνωριστικό (identifier). Αναγνωριστικά λέγονται επίσης και τα ονόματα που\r\n        επιλέγουμε για άλλα στοιχεία της java , όπως οι κλάσεις οι μέθοδοι κ.λ.π.\r\n    </p>\r\n    <p>\r\n        <code>\r\n        <b>int</b> myAge; \r\n    </code>\r\n    </p>\r\n    <p>\r\n        <code>\r\n        <b>String</b> myName; \r\n    </code>\r\n    </p>\r\n    <p>\r\n        <code>\r\n        <b>Boolean</b> isaMan; \r\n    </code>\r\n    </p>\r\n    <p>\r\n        Στην αρχή της δήλωσης , μπαίνει ο τύπος των δεδομένων:\r\n        <ul>\r\n            <li>\r\n                int -> ακέραιος\r\n            </li>\r\n            <li>\r\n                String -> αλφαριθμητικό\r\n            </li>\r\n            <li>\r\n                Boolean -> λογική μεταβλητή\r\n            </li>\r\n        </ul>\r\n        και στη συνέχεια το όνομα της μεταβλητής το οποίο επιλέγουμε εμείς (myAge, myName, isaMan). Αν έχουμε πολλές μεταβλητές του ίδιου τύπου μπορούμε να τις ορίσουμε στην ίδια γραμμή αφού της χωρίσουμε με κόμμα.\r\n    </p>\r\n    <p>\r\n        <code>int a, b, c;</code>\r\n    </p>\r\n    <p>\r\n        Το όνομα μιας μεταβλητής μπορεί να έχει μέχρι και 255 χαρακτήρες, πρέπει να αρχίζει από γράμμα, δολάριο <code>$</code> ή χαρακτήρα υπογράμμισης <code>_</code> και να μην περιέχει κενά. Δεν πρέπει να αρχίζει με αριθμό και να μην είναι ίδιο με λέξεις\r\n        οι οποίες είναι δεσμευμένες από την java. Μετά από τον πρώτο χαρακτήρα, η λέξη μπορεί να αποτελείται από άλλους χαρακτήρες ή γράμματα, δεν μπορεί όμως να αποτελείται από σύμβολα τα οποία χρησιμοποιούμε για να κάνουμε πράξεις (<code>+, -, *, /, %, @</code>,\r\n        κ.τ.λ.)\r\n    </p>\r\n    <p>\r\n        Η java υποστηρίζει το σύνολο των χαρακτήρων Unicode, το οποίο χρησιμοποιεί 16 Bit (265535) διαφορετικούς χαρακτήρες τους οποίους χρησιμοποιεί και το κώδικας ASCII (οι πρώτοι 256 χαρακτήρες).\r\n    </p>\r\n    <h4>\r\n        Δεσμευμένες (keywords)\r\n    </h4>\r\n    <p>\r\n        Είναι οι λέξεις που χρησιμοποιεί η java ως εντολές, οι οποίες αναγνωρίζονται από τον μεταγλωττιστή. Μια μεταβλητή δεν μπορεί να πάρει το όνομα μιας δεσμευμένης λέξης. Στον παρακάτω πίνακα θα δούμε τις δεσμευμένες λέξεις της γλώσσας.\r\n    </p>\r\n    <table class=\"table table-striped\">\r\n        <tr>\r\n            <td>Abstract</td>\r\n            <td>Do</td>\r\n            <td>Import</td>\r\n            <td>Public</td>\r\n            <td>Throws</td>\r\n        </tr>\r\n        <tr>\r\n            <td>Boolean</td>\r\n            <td>Double</td>\r\n            <td>Instanceof</td>\r\n            <td>Return</td>\r\n            <td>Transient</td>\r\n        </tr>\r\n        <tr>\r\n            <td>Break</td>\r\n            <td>Else</td>\r\n            <td>Int</td>\r\n            <td>Short</td>\r\n            <td>Try</td>\r\n        </tr>\r\n        <tr>\r\n            <td>Byte</td>\r\n            <td>Extends</td>\r\n            <td>Interface</td>\r\n            <td>Static</td>\r\n            <td>Void</td>\r\n        </tr>\r\n        <tr>\r\n            <td>Case</td>\r\n            <td>Final</td>\r\n            <td>Long</td>\r\n            <td>Strictfp</td>\r\n            <td>Volatile</td>\r\n        </tr>\r\n        <tr>\r\n            <td>Catch</td>\r\n            <td>Finally</td>\r\n            <td>Native</td>\r\n            <td>Super</td>\r\n            <td>While</td>\r\n        </tr>\r\n        <tr>\r\n            <td>Char</td>\r\n            <td>Float</td>\r\n            <td>New</td>\r\n            <td>Switch</td>\r\n            <td>Null</td>\r\n        </tr>\r\n        <tr>\r\n            <td>Class</td>\r\n            <td>For</td>\r\n            <td>Package</td>\r\n            <td>Synchronized</td>\r\n            <td>True</td>\r\n        </tr>\r\n        <tr>\r\n            <td>Continue</td>\r\n            <td>If</td>\r\n            <td>Private</td>\r\n            <td>This</td>\r\n            <td>False</td>\r\n        </tr>\r\n        <tr>\r\n            <td>Default</td>\r\n            <td>Implements</td>\r\n            <td>Protected</td>\r\n            <td>Throw</td>\r\n            <td>goto</td>\r\n        </tr>\r\n    </table>\r\n    <p>\r\n        <a href=\"./learn.php?level=2&step=exercise#5\">Δες την λυμένη άσκηση</a>\r\n    </p>\r\n</div>\r\n\r\n<h3>Ακέραιοι τύποι δεδομένων</h3>\r\n<div>\r\n    <p>\r\n        Μεταβλητές οι οποίες φιλοξενούν ακέραια δεδομένα (integer) είναι τεσσάρων τύπων <code>Byte, short, int</code> και <code>long</code>. Οι ακέραιοι μπορεί να είναι είτε θετικοί είτε αρνητικοί.\r\n    </p>\r\n    <p>\r\n        Στον παρακάτω πίνακα φαίνονται οι ακέραιοι τύποι δεδομένων, το μέγεθος της μνήμης που καταλαμβάνουν και το εύρος των τιμών τους.\r\n    </p>\r\n    <table class=\"table table-striped\">\r\n        <tr>\r\n            <th>Τύπος</th>\r\n            <th>Δεσμευμένη μνήμη σε bits </th>\r\n            <th>Εύρος τιμών </th>\r\n        </tr>\r\n        <tr>\r\n            <td>byte</td>\r\n            <td>8</td>\r\n            <td>-128 έως 127</td>\r\n        </tr>\r\n        <tr>\r\n            <td>short</td>\r\n            <td>32</td>\r\n            <td>-32768 έως 32767</td>\r\n        </tr>\r\n        <tr>\r\n            <td>int</td>\r\n            <td>64</td>\r\n            <td>-2147483648 έως 2147483647</td>\r\n        </tr>\r\n        <tr>\r\n            <td>long</td>\r\n            <td></td>\r\n            <td>-9223372036854775808 έως 9223372036854775807</tr>\r\n        </tr>\r\n    </table>\r\n    <p>\r\n        <code>Int number;</code></p>\r\n    <p>\r\n        <code>Int number=1000000; </code></p>\r\n    <p>\r\n        <code>Byte count=100; </code></p>\r\n    <p>\r\n        <code>Short amount2=-27652; </code>\r\n    </p>\r\n    <p>\r\n        Ποιόν όμως τύπο διαλέγουμε συχνότερα στα προγράμματά μας; Ο κανόνας είναι να διαλέγουμε τον μικρότερο τύπο δεδομένων, στον οποίο μπορεί να αποθηκευτεί ο μεγαλύτερος αριθμός που θα χρησιμοποιήσει το πρόγραμμά μας. Με αυτή την μέθοδο επιτυγχάνεται η αύξηση\r\n        της ταχύτητας του προγράμματός μας. Παρόλα αυτά όμως, συχνότερα χρησιμοποιείται ο τύπος int.\r\n    </p>\r\n    <p>\r\n        Όλοι οι ακέραιοι αριθμοί θεωρούνται ότι δίνονται στο δεκαδικό σύστημα, όμως μπορούν να εκφραστούν και με οκταδική ή δεκαεξαδική μορφή. Ένα \"0\" (μηδέν) μπροστά από έναν αριθμό σημαίνει ότι αυτός είναι σε οκταδική μορφή (π.χ. 057), ενώ ένα \"0x\" σημαίνει\r\n        ότι είναι σε δεκαεξαδική (π.χ. 0x100, 0x4FC8). Οι δεκαεξαδικοί αριθμοί έχουν ψηφία από 0 έως 9 και γράμματα A, B, C, D, E, F (ή a, b, c, d, e, f).\r\n    </p>\r\n    <p>\r\n        Οι ακέραιες μεταβλητές παρουσιάζουν μια ιδιότητα που ονομάζεται αναδίπλωση(wrapping). Αν δηλαδή αυξήσουμε ή μειώσουμε μια μεταβλητή, πέρα από την μέγιστη ή την ελάχιστή της, η μεταβλητή αυτή θα αναδιπλωθεί. Για παράδειγμα, αν αυξήσουμε κατά ένα μια ακέραια\r\n        μεταβλητή τύπου byte με τιμή 127 (μέγιστη τιμή της), θα πάρει την τιμή -128. Αντίστροφα αν την μειώσουμε κατά ένα από την ελάχιστη τιμή της (-128), θα πάρει την τιμή 127.\r\n    </p>\r\n</div>\r\n\r\n\r\n<h3>Αριθμοί κινητής υποδιαστολής</h3>\r\n<div>\r\n    <p>\r\n        Αριθμοί οι οποίοι δεν είναι ακέραιοι αποθηκεύονται σαν αριθμοί κινητής υποδιαστολής (floating point). Αυτοί οι αριθμοί έχουν ακέριο ή δεκαδικό μέρος και μπορεί να είναι θετικοί είτε αρνητικοί.\r\n    </p>\r\n    <p>Παραδείγματα αυτών είναι 55.598 ή -134.654. Οι συγκριμένοι αριθμοί λέγονται κινητής υποδιαστολής διότι η υποδιαστολή που έχουν μπορεί να “κινείται”. Για παράδειγμα έχουμε τους αριθμούς 7700.0, 0.00077 και 77000000000.0, τους οποίους μπορούμε να τους\r\n        γράψουμε με τα ίδια ψηφία, αλλάζοντας μόνο τον εκθέτη τους, 77 x 10^2, 77 x 10^-5, 77 x 10^9.\r\n    </p>\r\n    <p>\r\n        Οι αριθμοί κινητής υποδιαστολής ανάλογα με την ακρίβεια που παρέχουν χωρίζονται σε float και double.\r\n    </p>\r\n    <table class=\"table table-striped\">\r\n        <tr>\r\n            <th>Τύπος</th>\r\n            <th>Δεσμευμένη μνήμη σε bytes</th>\r\n            <th>Εύρος τιμών</th>\r\n            <th>Ακρίβεια</th>\r\n        </tr>\r\n        <tr>\r\n            <td>Float</td>\r\n            <td>4</td>\r\n            <td>-3.4x10^38 έως 3.4x10^38</td>\r\n            <td>7 ψηφία</td>\r\n        </tr>\r\n        <tr>\r\n            <td>Double</td>\r\n            <td>8</td>\r\n            <td>-1.7x10^308 έως 1.7x10^308</td>\r\n            <td>18 ψηφία </td>\r\n        </tr>\r\n    </table>\r\n    <p>\r\n        Η δήλωση των μεταβλητών κινητής υποδιαστολής γίνεται ακριβώς όπως και με τις υπόλοιπες μεταβλητές.\r\n    </p>\r\n    <p>\r\n        <code><b>Float</b> number;</code>\r\n    </p>\r\n    <p>\r\n        <code><b>Float</b> number=134.56;</code>\r\n    </p>\r\n    <p>\r\n        <code><b>Double</b> number1;</code>\r\n    </p>\r\n    <p>\r\n        <code><b>Double</b> number1=13456.456;</code>\r\n    </p>\r\n\r\n    <h3>Οι μοναδιαίοι τελεστές αύξησης και μείωσης</h3>\r\n    <p>\r\n        Οι τελεστές αύξησης και μείωσης, μεταβάλουν την τιμή μιας μεταβλητής, προσθέτοντας ή αφαιρώντας από αυτή μια μονάδα. Έτσι αν μια μεταβλητή x τύπου int έχει την τιμή 10, η έκφραση <code>++x</code> δίνει στην μεταβλητή αυτή την τιμή 11, ενώ η έκφραση\r\n        <code>--x</code> δίνει στην μεταβλητή την τιμή 9. Οι τελεστές <code>++ --</code>, μπορούν να τοποθετούνται είτε από αριστερά είτε από δεξιά της μεταβλητής. Αυτό αποφέρει το ίδιο αποτέλεσμα με μια μόνο διαφορά στην περίπτωση που αναθέσουμε την\r\n        μεταβλητή μας σε άλλη μεταβλητή.\r\n    </p>\r\n    <p>\r\n        Για παράδειγμα, έστω ότι έχουμε μια μεταβλητή x=10. Αν θέλουμε να πούμε ότι μια άλλη μεταβλητή παίρνει την τιμή <code>y=x;</code>\r\n        <ul>\r\n            <li>Όταν <code>y=x++</code>, η μεταβλητή y αρχικά θα πάρει την τιμή 10 και στην συνέχεια την τιμή 11.\r\n            </li>\r\n            <li>Όταν <code>y=++x</code>, η μεταβήτή y θα πάρει την τιμή 11, γιατί πρώτα το x θα γίνει 11 και ύστερα θα δώσει την τιμή του στο y. .\r\n            </li>\r\n        </ul>\r\n        Κάτι αντίστοιχο ισχύει και για τον τελεστή <code>--</code>\r\n    </p>\r\n    <p>\r\n        <a href=\"./learn.php?level=2&step=exercise#6\">Δες την λυμένη άσκηση</a>\r\n    </p>\r\n</div>\r\n\r\n<h3>Οι τελεστές των αριθμητικών πράξεων</h3>\r\n<div>\r\n    <p>\r\n        Οι τελεστές των αριθμητικών πράξεων περιλαμβάνουν τους γνωστούς τελεστές\r\n        <ul>\r\n            <li>Πρόσθεσης <code>+</code></li>\r\n            <li>Αφαίρεσης <code>-</code></li>\r\n            <li>Πολλαπλασιασμού <code>*</code></li>\r\n            <li>Διαίρεσης <code>/</code></li>\r\n            <li>Υπολοίπου ή modulo <code>%</code></li>\r\n        </ul>\r\n    </p>\r\n    <p>\r\n        Τους τελεστές αυτούς μπορούμε να τους χωρίσουμε σε δύο ομάδες:\r\n        <ol>\r\n            <li>Τους πολλαπλασιαστικούς τελεστές (<code>*, /, %</code>) που έχουν υψηλότερη προτεραιότητα</li>\r\n            <li>Τους προσθετικούς τελεστές (<code>+, -</code>) που έχουν χαμηλότερη προτεραιότητα</li>\r\n        </ol>\r\n    </p>\r\n    <p>\r\n        Αν και οι ανωτέρω τελεστές είναι ευρέως γνωστοί, χρειάζονται πάντα προσοχή σχετικά με τα αποτελέσματα που προκύπτουν. Αν για παράδειγμα προσθέσουμε δύο μεταβλητές διαφορετικών τύπων, π.χ. μια τύπου byte μια τύπου int, το αποτέλεσμα θα είναι του ίδιου\r\n        τύπου με αυτό της επικρατέστερης, στη περίπτωσή μας int. Το αποτέλεσμα δεν επηρεάζει μεταβλητές ίδιου τύπου. Αν ένας από τους σύ προσθετέους είναι πραγματικός αριθμός (κινητής υποδιαστολής), και το αποτέλεσμα θα είναι πραγματικός. Πρόβλημα δημιουργείτε\r\n        και στην περίπτωση που ο πολλαπλασιασμός δύο αριθμών δίνει αποτέλεσμα μεγαλύτερο της χωρητικότητας του τύπου των αριθμών. Για παράδειγμα αν πολλαπλασιάσομε δύο μεταβλητές τύπου byte, όπου η μια έχει την τιμή 64 και η άλλη την τιμή 4, το αποτέλεσμα\r\n        που μας δίνουν είναι 256, όπου είναι μια τιμή έξω από τo εύρος του ακεραίου αυτού τύπου. Αν έχουμε επιλέξει μια μεταβλητή byte για να φιλοξενήσει το αποτέλεσμα, αυτή θα πάρει την τιμή 0, καθώς και τα 8 ψηφία χαμηλής τάξεως του αποτελέσματος θα\r\n        είναι 0.\r\n    </p>\r\n    <p>\r\n        Άλλο παράδειγμα δείχνει, ότι αν έχουμε ορίσει μια μεταβλητή τύπου int, για να κρατήσει το αποτέλεσμα μια διαίρεσης, η διαίρεση 7/4 θα αποθηκεύσει στην μεταβλητή τον αριθμό 1, ενώ κανονικά το αποτέλεσμα είναι 1.75. Έτσι, σε διάφορες περιπτώσεις να κάνουμε\r\n        πρώτα τους πολλαπλασιασμούς και μετά τις διαιρέσει κινδυνεύουμε να οδηγηθούμε σε υπερχείλιση, ενώ αν κάνουμε πρώτα τις διαιρέσεις και μετά τους πολλαπλασιασμούς κινδυνεύουμε να χάσουμε σε ακρίβεια.\r\n    </p>\r\n    <p>\r\n        Μερικές σημαντικές πληροφορίες για την χρήση των τελεστών και την ορθή σύνταξη και λειτουργία των πράξεων\r\n        <ol>\r\n            <li>Πρώτα εκτελούμε τις πράξεις στις παρενθέσεις (αν υπάρχουν παρενθέσεις μέσα σε άλλες παρενθέσεις, πρώτα κάνουμε τις εσωτερικές)</li>\r\n            <li>Στη συνέχεια κάνουμε τους πολλαπλασιασμούς, τις διαιρέσεις και τις ακέραιες διαιρέσεις.</li>\r\n            <li>Ύστερα συνεχίζουμε με την εκτέλεση των πράξεων που έχουν προσθέσεις και αφαιρέσεις.</li>\r\n            <li>Τέλος εκχωρούμε την τιμή που βρίσκεται δεξιά από το σύμβολο <code>=</code> στην μεταβλητή που είναι αριστερά του.</li>\r\n        </ol>\r\n    </p>\r\n    <p>\r\n        <a href=\"./learn.php?level=2&step=exercise#7\">Δες την λυμένη άσκηση</a>\r\n    </p>\r\n\r\n    <h4>\r\n        Περισσότερα για τις εκχωρήσεις\r\n    </h4>\r\n    <p>\r\n        Μια εκχώρηση στα μαθηματικά μοιάζει αρκετά με ισότητα, όμως στην πραγματικότητα δεν είναι έτσι. Όταν για παράδειγμα δηλώσουμε ότι <code>x=x+5</code>, αυτό σημαίνει ότι αρχικά υπολογίζεται το δεξιό μέλος (πρόσθεση του 5 στο x) και το αποτέλεσμα\r\n        που προκύπτει εκχωρείται ως νέα τιμή του x.\r\n    </p>\r\n    <p>Αντί να γράψουμε <code>x = x + y</code> μπορούμε να γράψουμε και <code>x += y</code></p>\r\n    <p>Αντί να γράψουμε <code>x = x - y</code> μπορούμε να γράψουμε και <code>x -= y</code></p>\r\n    <p>Αντί να γράψουμε <code>x = x * y</code> μπορούμε να γράψουμε και <code>x *= y</code></p>\r\n    <p>Αντί να γράψουμε <code>x = x / y</code> μπορούμε να γράψουμε και <code>x /= y</code></p>\r\n    <p>\r\n        <a href=\"./learn.php?level=2&step=exercise#8\">Δες την λυμένη άσκηση</a>\r\n    </p>\r\n</div>\r\n\r\n<h3>Τελεστές σύγκρισης</h3>\r\n<div>\r\n    <p>Οι τελεστές σύγκρισης φαίνονται στον παρακάτω πίνακα </p>\r\n    <table class=\"table table-striped\">\r\n        <tr>\r\n            <th>Τελεστής</th>\r\n            <th>Σημασία</th>\r\n            <th>Παράδειγμα</th>\r\n        </tr>\r\n        <tr>\r\n            <td>==</td>\r\n            <td>Ίσον</td>\r\n            <td><code>Χ == 10</code></td>\r\n        </tr>\r\n        <tr>\r\n            <td>!=</td>\r\n            <td>Διάφορο</td>\r\n            <td><code>Χ != 10</code></td>\r\n        </tr>\r\n        <tr>\r\n            <td>&lt;</td>\r\n            <td>Μικρότερο</td>\r\n            <td><code>Χ &lt; 10</code></td>\r\n        </tr>\r\n        <tr>\r\n            <td>&gt;</td>\r\n            <td>Μεγαλύτερο</td>\r\n            <td><code>Χ &gt; 10</code></td>\r\n        </tr>\r\n        <tr>\r\n            <td>&lt;</td>\r\n            <td>Μικρότερο ή ίσο</td>\r\n            <td><code>Χ &lt;= 10</code></td>\r\n        </tr>\r\n        <tr>\r\n            <td>&gt;</td>\r\n            <td>Μεγαλύτερο ή ίσο</td>\r\n            <td><code>Χ &gt;= 10</code></td>\r\n        </tr>\r\n    </table>\r\n    <p>Όλοι οι τελεστές της σύγκρισης δίνουν αποτέλεσμα λογικές τιμές (true,false). Προσοχή πρέπει να υπάρχει στον τελεστή εκχώρησης με τον τελεστή ισότητας.</p>\r\n</div>\r\n\r\n<h3>Λογικοί τελεστές</h3>\r\n<div>\r\n    <p>\r\n        Με τους λογικούς τελεστές (Boolean operators) μπορούμε να συνδυάσουμε δύο ή περισσότερες λογικές εκφράσεις και έτσι να δημιουργηθεί μια πίο σύνθετη λογική πρόταση. Όταν λέμε “έχω αυτοκίνητο ΚΑΙ μηχανή”, χρησιμοποιούμε τον τελεστή AND, ενώ όταν λέμε “θα\r\n        πληρώσεις με μετρητά Ή πιστωτική” κάνουμε χρήση του τελεστή OR. Οι βασικοί τελεστές περιλαμβάνονται στον παρακάτω πίνακα\r\n    </p>\r\n    <table class=\"table table-striped\">\r\n        <tr>\r\n            <th>Λογικός τελεστής</th>\r\n            <th>Σύμβολο</th>\r\n        </tr>\r\n        <tr>\r\n            <td>AND</td>\r\n            <td><code>&&</code></td>\r\n        </tr>\r\n        <tr>\r\n            <td>OR</td>\r\n            <td><code>||</code></td>\r\n        </tr>\r\n        <tr>\r\n            <td>NOT</td>\r\n            <td><code>!</code></td>\r\n        </tr>\r\n        <tr>\r\n            <td>XOR</td>\r\n            <td><code>^</code></td>\r\n        </tr>\r\n    </table>\r\n    <ul>\r\n        <li>Ο τελεστής AND (<code>&&</code>) συνδέει δύο ή περισσότερες λογικές προτάσεις και η τελική πρόταση είναι αληθής όταν είναι αληθής και οι προηγούμενες προτάσεις. Για παράδειγμα η έκφραση <code>(4+2==6)&&(5+2==7)</code> είναι αληθής ενώ η έκφραση\r\n            <code>(4+2==6)&&(5+2==10)</code> είναι ψευδής.</li>\r\n        <li>Ο τελεστής OR (<code>||</code>) συνδέει δύο ή περισσότερες λογικές προτάσεις και η τελική πρόταση είναι αληθής αν μια τουλάχιστον από τις προτάσεις που ενώνονται είναι αληθής. Για παράδειγμα η έκφραση <code>(4+2==6)||(5+2==7)</code> είναι αληθής,\r\n            όπως και η πρόταση\r\n            <code>(4+2==18)||(5+2==7)</code>. Η πρόταση <code>(4+2==8)||(5+2==37)</code> είναι ψευδής. </li>\r\n        <li>Ο τελεστής NOT (<code>!</code>) αντιστρέφει μια λογική πρόταση Για παράδειγμα η πρόταση <code>(3+3=45)</code> είναι ψευδής, η πρόταση <code>!(3+3==45)</code> είναι αληθής. </li>\r\n        <li>Ο τελεστής XOR (<code>^</code>) συνδέει δύο λογικές προτάσεις και χρησιμοποιείτε για να εξακριβώσει αν μια και μόνο μια από τις προτάσεις είναι αληθής. Η έκφραση <code>(4+2==6)^(5+2==7)</code> είναι ψευδής (γιατί και οι δύο επιμέρους προτάσεις\r\n            είναι αληθείς), όπως και η έκφραση\r\n            <code>(4+2==16)^(5+2=17)</code>. Αληθής είναι η έκφραση <code>(4+2==6)^(5+2==17)</code> ή η έκφραση <code>(4+2==16)^(5+2==7)</code>. </li>\r\n    </ul>\r\n    <p>\r\n        <a href=\"./learn.php?level=2&step=exercise#9\">Δες την λυμένη άσκηση</a>\r\n    </p>\r\n</div>\r\n\r\n<h3>Τελεστές δυαδικών ψηφίων</h3>\r\n<div>\r\n    <p>\r\n        Λογικές πράξεις γίνονται όχι μόνο μεταξύ λογικών παραστάσεων αλλά και μεταξύ ακέραιων αριθμών. Στην περίπτωση αυτή, η τελική τιμή προκύπτει ψηφίο προς ψηφίο πράξη μεταξύ των αριθμητικών ποσοτήτων. Υπάρχουν τέσσερις τελεστές δυαδικών ψηφίων (bitwise operators),\r\n        τους οποίους βλέπουμε στον επόμενο πίνακα\r\n    </p>\r\n    <table class=\"table table-striped\">\r\n        <tr>\r\n            <th>Τελεστής δυαδικών ψηφίων</th>\r\n            <th>Σύμβολο</th>\r\n        </tr>\r\n        <tr>\r\n            <td>Bitwise AND</td>\r\n            <td><code>&</code></td>\r\n        </tr>\r\n        <tr>\r\n            <td>Bitwise OR</td>\r\n            <td><code>^</code></td>\r\n        </tr>\r\n        <tr>\r\n            <td>Bitwise NOT</td>\r\n            <td><code>|</code></td>\r\n        </tr>\r\n        <tr>\r\n            <td>Συμπλήρωμα</td>\r\n            <td><code>~</code></td>\r\n        </tr>\r\n    </table>\r\n    <p>Η δράση των τελεστών φαίνεται στους πίνακες παρακάτω </p>\r\n    <table class=\"table table-striped\">\r\n        <tr>\r\n            <th>Op1</th>\r\n            <th>Op2</th>\r\n            <th>Op1&Op2</th>\r\n            <th>Op1|Op2</th>\r\n            <th>Op1^Op2</th>\r\n        </tr>\r\n        <tr>\r\n            <td>0</td>\r\n            <td>0</td>\r\n            <td>0</td>\r\n            <td>0</td>\r\n            <td>0</td>\r\n        </tr>\r\n        <tr>\r\n            <td>1</td>\r\n            <td>0</td>\r\n            <td>0</td>\r\n            <td>1</td>\r\n            <td>1</td>\r\n        </tr>\r\n        <tr>\r\n            <td>0</td>\r\n            <td>1</td>\r\n            <td>0</td>\r\n            <td>1</td>\r\n            <td>1</td>\r\n        </tr>\r\n        <tr>\r\n            <td>1</td>\r\n            <td>1</td>\r\n            <td>1</td>\r\n            <td>1</td>\r\n            <td>0</td>\r\n        </tr>\r\n    </table>\r\n    <table class=\"table table-striped\">\r\n        <tr>\r\n            <th>Op</th>\r\n            <th>~Op</th>\r\n        </tr>\r\n        <tr>\r\n            <td>0</td>\r\n            <td>1</td>\r\n        </tr>\r\n        <tr>\r\n            <td>1</td>\r\n            <td>0</td>\r\n        </tr>\r\n    </table>\r\n    <p>\r\n        <a href=\"./learn.php?level=2&step=exercise#10\">Δες την λυμένη άσκηση</a>\r\n    </p>\r\n</div>\r\n\r\n<h3>\r\n    Χαρακτήρες\r\n</h3>\r\n<div>\r\n    <p>\r\n        Ένα στοιχείο του χαρακτήρα (char από το character), περιλαμβάνει έναν οποιανδήποτε χαρακτήρα (γράμμα, ψηφίο, σημείο στίξης, κενό κ.λπ..). Ο χαρακτήρας πρέπει να περικλείεται σε μονά εισαγωγικά. Μια μεταβλητή τύπου char μπορούμε απλώς να την δηλώσουμε\r\n        ή να την δηλώσουμε και να της αποδώσουμε τιμή ταυτοχρόνως.\r\n    </p>\r\n    <p>\r\n        <code><b>Char</b> myCharacter;</code>\r\n    </p>\r\n    <p>\r\n        <code><b>Char</b>  myCharacter=\'b\';</code>\r\n    </p>\r\n    <p>\r\n        Για να αναπαραστήσουμε μέσα στο πρόγραμμά μας ορισμένους ειδικούς χαρακτήρες, όπως αλλαγή γραμμής, πλήκτρο οπισθοδρόμησης, χρησιμοποιούμε τις ακολουθίες διαφυγής (escape sequences). Μια ακολουθία διαφυγής αποτελείται από μια ανάποδη κάθετο <code></code>        μαζί με ένα χαρακτήρα. Παρακάτω βλέπουμε μερικές από τις ακολουθίες διαφυγής\r\n    </p>\r\n    <table class=\"table table-striped\">\r\n        <tr>\r\n            <th>Ακολουθία</th>\r\n            <th>Σημασία</th>\r\n        </tr>\r\n        <tr>\r\n            <td><code>\\b</code></td>\r\n            <td>Οπισθοδρόμηση (backspace)</td>\r\n        </tr>\r\n        <tr>\r\n            <td><code>\\t</code></td>\r\n            <td>Χαρακτήρας στηλοθέτη(tab)</td>\r\n        </tr>\r\n        <tr>\r\n            <td><code>\\n</code></td>\r\n            <td>Αλλαγή γραμμής (line feed)</td>\r\n        </tr>\r\n        <tr>\r\n            <td><code>\\f</code></td>\r\n            <td>Αλλαγή σελίδας (form feed)</td>\r\n        </tr>\r\n        <tr>\r\n            <td><code>\\r</code></td>\r\n            <td>Χαρακτήρας επιστροφής (carriage return)</td>\r\n        </tr>\r\n        <tr>\r\n            <td><code>\\\'\'</code></td>\r\n            <td>Διπλά εισαγωγικά</td>\r\n        </tr>\r\n        <tr>\r\n            <td><code>\\\'</code></td>\r\n            <td>Μονά εισαγωγικά</td>\r\n        </tr>\r\n        <tr>\r\n            <td><code>\\</code></td>\r\n            <td>Aνάποδη κάθετος (backslash)</td>\r\n        </tr>\r\n    </table>\r\n    <p>\r\n        Σε μια μεταβλητή τύπου char μπορούμε να δώσουμε ως τιμή την ακολουθία διαφυγής που ακολουθεί στη αλλαγή γραμμής.\r\n    </p>\r\n    <p>\r\n        <code><b>Char</b> myCharacter = \'\\n\'</code>\r\n    </p>\r\n    <p>\r\n        Όπως έχουν αναφέρει η java χρησιμοποιεί σύστημα χαρακτήρων Unicode. Το σύστημα αυτό χρησιμοποιεί 2 bytes για την αναπαράσταση των χαρακτήρων, όπου συμπεριλαμβάνει την αλφαβήτα όλων των γλωσσών, καθώς έχει την δυνατότητα αποθήκευσης 65536 χαρακτήρων.\r\n    </p>\r\n    <p>\r\n        Δυστυχώς κάποια προγράμματα και λειτουργικά συστήματα δεν υποστηρίζουν το σύστημα Unicode. Οι πρώτοι 128 χαρακτήρες του συστήματος Unicode είναι οι ίδιοι με τους 128 πρώτους χαρακτήρες του κώδικα ASCII, άρα με το πρότυπο ASCII δεν υπάρχουν προβλήματα.\r\n        Οι επόμενοι 128 χαρακτήρες, ταυτίζονται με τους τελευταίους χαρακτήρες του εκτελεσμένου συστήματος ISO-LATIN-1 ASCII. Από εκεί και πέρα ίσως να εμφανιστούν προβλήματα.\r\n    </p>\r\n    <p>\r\n        Αναφερόμενοι σε ένα συγκεκριμένο χαρακτήρα Unicode, χρησιμοποιούμε την ακολουθία διαφυγής u την οποία ακολουθεί ένας τετραψήφιος δεκαεξαδικός αριθμός. Για να εκχωρήσουμε σε μια μεταβλητή το κεφαλαίο λατινικό γράμμα X, του οποίο ο κώδικας Unicode είναι\r\n        0058 γράφουμε\r\n    </p>\r\n    <p>\r\n        <code><b>Char</b> mychar=\'\\u0058\';</code>\r\n    </p>\r\n    <p>\r\n        <a href=\"./learn.php?level=2&step=exercise#11\">Δες την λυμένη άσκηση</a>\r\n    </p>\r\n</div>\r\n\r\n<h3>Αλφαριθμητικά</h3>\r\n<div>\r\n    <p>\r\n        Σε όλες τις γλώσσες προγραμματισμού με τον όρο αλφαριθμητικά εννοούμε ένα σύνολο από χαρακτήρες. Στην γλώσσα Java είναι η λέξη αλφαριθμητικά είναι κάτι πιο συγκεκριμένο, είναι ένα αντικείμενο στην κλάσης String. Αφού το αλφαριθμητικό είναι αντικείμενο,\r\n        διαθέτει διάφορες μεθόδους όπου βοηθούν στον καλύτερο χειρισμό του. Κάθε αλφαριθμητικό πρέπει να περικλείετε ανάμεσα σε διπλά εισαγωγικά π.χ.(“Hello World”).\r\n    </p>\r\n    <p>\r\n        <a href=\"./learn.php?level=2&step=exercise#12\">Δες την λυμένη άσκηση</a>\r\n    </p>\r\n</div>\r\n\r\n<h3>Αρχικές τιμές για τις μεταβλητές μέλη</h3>\r\n<div>\r\n    <p>\r\n        Στις μεταβλητές μέλη (member variables) τις οποίες δεν δίνουμε αρχική τιμή όταν τις δηλώνουμε, η Java εκχωρεί από μόνη της αρχική τιμή, η οποία εξαρτάται από τον τύπο της μεταβλητής μέλους. Οι αρχικές τιμές φαίνονται στον ακόλουθο πίνακα\r\n    </p>\r\n    <table class=\"table table-striped\">\r\n        <tr>\r\n            <th>Τύπος</th>\r\n            <th>Αρχική τιμή </th>\r\n            <th>Τύπος</th>\r\n            <th>Αρχική τιμή </th>\r\n        </tr>\r\n        <tr>\r\n            <td>Byte</td>\r\n            <td>0</td>\r\n            <td>Short</td>\r\n            <td>0</td>\r\n        </tr>\r\n        <tr>\r\n            <td>Int</td>\r\n            <td>0</td>\r\n            <td>Long</td>\r\n            <td>0L</td>\r\n        </tr>\r\n        <tr>\r\n            <td>Float</td>\r\n            <td>0.0f</td>\r\n            <td>Double</td>\r\n            <td>0.0d </td>\r\n        </tr>\r\n        <tr>\r\n            <td>Char</td>\r\n            <td>\'\\u0000\' </td>\r\n            <td>Boolean</td>\r\n            <td>false</td>\r\n        </tr>\r\n        <tr>\r\n            <td>Αναφορά σε αντικείμενο </td>\r\n            <td>Null</td>\r\n            <td></td>\r\n            <td></td>\r\n        </tr>\r\n    </table>\r\n</div>\r\n\r\n<h3>Μετατροπή τύπου δεδομένων</h3>\r\n<div>\r\n    <p>\r\n        Ως μετατροπή δεδομένων (casting) νοείται η διαδικασία με την οποία μετατρέπουμε έναν τύπο δεδομένων, σε έναν άλλο. Αλλαγή αυτή γίνεται για απλούς τύπους δεδομένων αλλά και για τύπους κλάσεων. Για να γίνει η μετατροπή, τοποθετούμε τον τύπο που θέλουμε\r\n        να έχε η μεταβλητή σε παρένθεση πριν το όνομα της μεταβλητής.\r\n    </p>\r\n    <p>\r\n        <code>(επιθυμητός τύπος) μεταβλητή </code>\r\n    </p>\r\n    <p>\r\n        Μια τέτοια μετατροπή θα μπορούσε να γίνει σε περίπτωση διαίρεσης από int σε double για παράδειγμα.\r\n    </p>\r\n    <xmp>\r\n        Double d1 = 3.2;\r\n        Double d2 = 3.9999;  \r\n        Int iresult;\r\n        \r\n        iresult = (int)d1; // το iresult έχει την τιμή 3      \r\n        iresult = (int)d2; // το iresult έχει την τιμή 3\r\n    </xmp>\r\n    <p>\r\n        <a href=\"./learn.php?level=2&step=exercise#13\">Δες την λυμένη άσκηση</a>\r\n    </p>\r\n    <p>Η μετατροπή η οποία δηλώνετε όπως πιο πάνω λέγετε ρητή μετατροπή (explicit casting). Υπάρχει όμως και η έμμεση μετατροπή (implicit casting). Αυτού του είδους η μετατροπή ενεργεί από μόνη της και αλλάζι υτον τύπο της μεταβλητής χωρίς αν έχει δοθεί\r\n        εντολή από τον χρήστη. </p>\r\n    <p>\r\n        <a href=\"./learn.php?level=2&step=exercise#14\">Δες την λυμένη άσκηση</a>\r\n    </p>\r\n</div>\r\n\r\n<h3>Μαθηματικές συναρτήσεις</h3>\r\n<div>\r\n    <p>Η μαθηματικές συναρτήσεις είναι σημαντικές για την δημιουργία κώδικα. Η Java παρέχει έναν αριθμό μεθόδων που υποστηρίζουν τέτοιες συναρτήσεις και είναι μέρος μια βασικής βιβλιοθήκης που βρίσκεται στο πακέτο java.lang. Όλες αυτές οι μέθοδοι περιλαμβάνονται\r\n        στην κλάση Math και για να αναφερθούμε σε κάποια από αυτές πρέπει να γράψουμε αρχικά την λέξη Math. (μαζί με μια τελεία). Για παράδειγμα αν θέλουμε να υπολογίζουμε στην τετραγωνική ρίζα της μεταβλητής Π.χ. iVar, θα γράψουμε <code>Math.sqrt(iVar)</code>.\r\n        Στον παρακάτω πίνακα βλέπουμε κάποιες από τις πιο σημαντικές συναρτήσεις.</p>\r\n\r\n    <table class=\"table table-striped\">\r\n        <tr>\r\n            <th>Μέθοδος</th>\r\n            <th>Περιγραφή</th>\r\n            <th>Παράδειγμα</th>\r\n        </tr>\r\n        <tr>\r\n            <td>Abs(όρισμα)</td>\r\n            <td>Υπολογίζει την απόλυτη τιμή του ορίσματος. Το όρισμα είναι τύπου int, long, float, double. Το αποτέλεσμα είναι αντίστοιχου τύπου μ το όρισμα. </td>\r\n            <td><code>Abs(3)</code> είναι 3, <br/><code>Abs(-3)</code> είναι 3, <br/><code>Abs(0)</code> είναι 0 </td>\r\n        </tr>\r\n        <tr>\r\n            <td>Ceil(όρισμα) </td>\r\n            <td>Στρογγυλοποιεί το όρισμα στο μικρότερο ακέραιο που είναι μεγαλύτερος ή ίσος από αυτό. Το όρισμα μπορεί να είναι double. Τύπου double είναι και το αποτέλεσμα.</td>\r\n            <td><code>Ceil(7.2)</code> είναι 8, <br/><code>Ceil(-7.8)</code> είναι -7 </td>\r\n        </tr>\r\n        <tr>\r\n            <td>Floor(όρισμα) </td>\r\n            <td>Επιστρέφει τον μικρότερο ακέραιο που είναι μικρότερος ή ίσος με το όρισμα(όρισμα και αποτέλεσμα τύπου double) </td>\r\n            <td><code>Floor(7.2)</code> είναι 7, <br/><code>Floor(-7.9)</code> είναι -8</td>\r\n        </tr>\r\n        <tr>\r\n            <td>Max(όρισμα) </td>\r\n            <td>Επιστρέφει το μεγαλύτερο από τα ορίσματα. Το άθροισμα μπορεί να είναι int, log, float, double. Αντίστοιχο είναι και το αποτέλεσμα.</td>\r\n            <td><code>Max(4.7 , 23.5)</code> είναι το  23.5, <br/><code>Max(-4.7 , -23.5)</code> είναι το -4.7</td>\r\n        </tr>\r\n        <tr>\r\n            <td>Min(όρισμα) </td>\r\n            <td>Επιστρέφει το μικρότερο από τα ορίσματα. Το άθροισμα μπορεί να είναι int, log, float, double. Αντίστοιχο είναι και το αποτέλεσμα. </td>\r\n            <td><code>Min(4.7 , 23.5)</code> είναι 4.7, <br/><code>Min(-4.7 , -23.5)</code> είναι -23.5 </td>\r\n        </tr>\r\n        <tr>\r\n            <td>Pow(ορ1,ορ2)</td>\r\n            <td>Υπολογίζει την δύναμη ορ1^ορ2 (ορίσματα και αποτελέσματα τύπου double) </td>\r\n            <td><code>Pow(2,7)</code> είναι 128, <br/><code>Pow(16, .5)</code> είναι το 4 </td>\r\n        </tr>\r\n        <tr>\r\n            <td>Round(όρισμα) </td>\r\n            <td>Υπολογίζει τον πλησιέστερο προς το όρισμα ακέραιο. Το όρισμα είναι τύπου float ή double. Το αποτέλεσμα είναι τύπου int και long αντίστοιχα. </td>\r\n            <td><code>Round(4.3)</code> είναι το 4, <br/><code>Round(4.8)</code> είναι το 5, <br/><code>Round(-4.8)</code> είναι το -5</td>\r\n        </tr>\r\n        <tr>\r\n            <td>Random() </td>\r\n            <td>Επιστρέφει ένα ψευδοτυχαίο αριθμό μεταξύ 0 και 1 </td>\r\n            <td></td>\r\n        </tr>\r\n        <tr>\r\n            <td>Sin(όρισμα) </td>\r\n            <td>Ημίτονο του ορίσματος. Το όρισμα είναι σε ακτίνια. Όρισμα και αποτέλεσμα τύπου double.</td>\r\n            <td><code>Sin(0.0)</code> είναι 0</td>\r\n        </tr>\r\n        <tr>\r\n            <td>Cos(όρισμα)</td>\r\n            <td>Συνημίτονο. Το όρισμα πρέπει να είναι τύπου double σε ακτίνια. Τύπου double είναι και το συνημίτονο. </td>\r\n            <td><code>Cos(0.0)</code> είναι 1</td>\r\n        </tr>\r\n        <tr>\r\n            <td>Tan(όρισμα) </td>\r\n            <td>Εφαπτόμενη του ορίσματος. Το όρισμα είναι σε ακτίνια. Όρισμα και αποτέλεσμα τύπου double. </td>\r\n            <td><code>Tan(0.0)</code> είναι 0</td>\r\n        </tr>\r\n        <tr>\r\n            <td>Sqrt(όρισμα)</td>\r\n            <td>Υπολογίζει την τετραγωνική ρίζα ενός αριθμού. Όρισμα και αποτέλεσμα είναι τύπου double. </td>\r\n            <td><code>Sqrt(900.0)</code> είναι 30</td>\r\n        </tr>\r\n        <tr>\r\n            <td>Exp(όρισμα) </td>\r\n            <td>Η συνάρτηση e^x (όρισμα αποτέλεσμα τύπου double)</td>\r\n            <td><code>Exp(1.0)</code> είναι 2.71828, <br/><code>Exp(2.0)</code> είναι 7.38906</td>\r\n        </tr>\r\n        <tr>\r\n            <td>Log(όρισμα)</td>\r\n            <td>Ο φυσικός λογάριθμος του ορίσματος (βάση e)</td>\r\n            <td><code>Log(2.717182)</code> είναι 1</td>\r\n        </tr>\r\n    </table>\r\n    <p>\r\n        <a href=\"./learn.php?level=2&step=exercise#15\">Δες την λυμένη άσκηση</a>\r\n    </p>\r\n</div>\r\n\r\n<h3>Μετατροπή αλφαριθμητικών σε αριθμούς</h3>\r\n<div>\r\n    <p>Μερικές φορές χρειάζεται να μετατραπεί ένα αλφαριθμητικό (εισαγόμενο συνήθως μέσω του πληκτρολογίου) σε αριθμητικό στοιχείο τύπου int, float, double. Για να γίνει αυτό χρησιμοποιούμε δύο μεθόδους.\r\n        <ul>\r\n            <li>την <code>valueOf(αλφαριθμητικό)</code></li>\r\n            <li><code>intValue()</code> για μετατροπή σε τύπο int <br/>\r\n                <code>longValue()</code> για μετατροπή σε τύπο long <br/>\r\n                <code>floatValue()</code> για μετατροπή σε τύπο float <br/>\r\n                <code>doubleValue()</code> για μετατροπή σε τύπο double </li>\r\n        </ul>\r\n    </p>\r\n    <p>\r\n        Για παράδειγμα\r\n        <ul>\r\n            <li>\r\n                Για να γίνει το αλφαριθμητικό “25” σε ακέραιο τύπου int πρέπει να γράψουμε:\r\n                <br/>\r\n                <code>\r\n                int i = Integer.valueOf(\"25\").intValue();\r\n            </code>\r\n            </li>\r\n            <li>\r\n                Για να γίνει το αλφαριθμητικό “25” σε ακέραιο τύπου long πρέπει να γράψουμε:\r\n                <br/>\r\n                <code>    \r\n                long l=long.valueOf(\"25\").longValue(); \r\n            </code>\r\n            </li>\r\n            <li>\r\n                Για να γίνει το αλφαριθμητικό “25.5” σε αριθμό τύπου float πρέπει να γράψουμε:\r\n                <br/>\r\n                <code>\r\n                float f=float.valueOf(\"25.5\").floatValue(); \r\n            </code>\r\n                <br/> και σε double:\r\n                <code>\r\n                double d=double.valueOf(\"25.5\").doubleValue(); \r\n            </code>\r\n            </li>\r\n        </ul>\r\n    </p>\r\n</div>\r\n\r\n<h3>Εισαγωγή δεδομένων από το πληκτρολόγιο</h3>\r\n<div>\r\n    <p>\r\n        Κατά το χρόνο της εκτέλεσης, μπορεί να χρειαστεί να εισάγουμε δεδομένα από το πληκτρολόγιο. Αυτό γίνεται προσθέτοντας ορίσματα στην εντολή του διερμηνευτή java όνομα_προγράμματος και αυτό γίνεται\r\n    </p>\r\n    <p>\r\n        <code>Java όνομα_προγράαμματος όρισμα 1 όρισμα 2 . . . </code>\r\n    </p>\r\n    <p>\r\n        Η java αποθηκεύει τα ορίσματα αυτά σε ένα πίνακα με όνομα args. Το πρώτο όρισμα αντιστοιχεί στο στοιχείο args[0] το δεύτερο args[1] κ.λ.π.\r\n    </p>\r\n    <p>\r\n        <a href=\"./learn.php?level=2&step=exercise#16\">Δες την λυμένη άσκηση</a>\r\n    </p>\r\n    <p><b>Η κλάση Scanner</b></p>\r\n    <p>\r\n        Για να κάνουμε στο πρόγραμμα διαθέσιμη την κλάση Scanner, ώστε να εισάγουμε δεδομένα από την κονσόλα (keyboard), πρέπει να γράψουμε στην αρχή του προγράμματος\r\n    </p>\r\n    <p>\r\n        <code>Import java.util.Scanner;</code>\r\n    </p>\r\n    <p>\r\n        Στη συνέχεια, δημιουργούμε ένα αντικείμενο της κλάσης Scanner με όνομα keyboard γράφοντας\r\n        <code>Scanner keyboard= new Scanner(System.in);</code>\r\n    </p>\r\n    <p>\r\n        Το όρισμα <code>System.in</code> που υπάρχει στην παρένθεση αντιπροσωπεύει το πληκτρολόγιο. Αφού δημιουργήσαμε το αντικείμενο keyboard, χρησιμοποιούμε δύο μεθόδους του αντικειμένου της κλάσης Scanner για να διαβάσουμε τα δεδομένα, την <code>nextInt</code>        και την <code>nextDouble</code>. H <code>nextInt</code> χρησιμοποιείται για ακέραια δεδομένα και η <code>nextDouble</code> για αριθμούς Double.\r\n    </p>\r\n    <p>\r\n        <code>x1=keyboard.nextInt(); <br/>\r\n        x2=keyboard.nextDouble();</code>\r\n    </p>\r\n    <p>\r\n        Στον παρακάτω πίνακα υπάρχουν μερικές από τις μεθόδους του αντικειμένου Scannner\r\n    </p>\r\n    <table class=\"table table-striped\">\r\n        <tr>\r\n            <th>Μέθοδος</th>\r\n            <th>Περιγραφή</th>\r\n        </tr>\r\n        <tr>\r\n            <td><code>next()</code></td>\r\n            <td>Επιστρέφει τα επόμενα δεδομένα που γράφουμε από το πληκτρολόγιο ως αλφαριθμητικό (String)</td>\r\n        </tr>\r\n        <tr>\r\n            <td><code>nextInt()</code></td>\r\n            <td>Επιστρέφει το επόμενο στοιχείο δεδομένων ως τιμή int.</td>\r\n        </tr>\r\n        <tr>\r\n            <td><code>nextDouble()</code></td>\r\n            <td>Επιστρέφει το επόμενο στοιχείο δεδομένων ως τιμή double.</td>\r\n        </tr>\r\n        <tr>\r\n            <td><code>nextLine()</code></td>\r\n            <td>Επιστρέφει το επόμενο στοιχείο δεδομένων ως το τέλος της γραμμής ως αλφαριθμητικό.</td>\r\n        </tr>\r\n    </table>\r\n    <p>\r\n        Κάθε στοιχείο δεδομένων που εισάγουμε ονομάζεται διακριτικό (token). Μπορούμε να γράψουμε δύο ή περισσότερα συνεχόμενα διακριτικά αρκεί να αφήσουμε ανάμεσά τους ειδικό κενό. Το ειδικό κενό μπορεί να είναι ένα ή περισσότερα πατήματα του πλήκτρου (space\r\n        bar), το πάτημα του πλήκτρου tab ή ένας χαρακτήρας επιστροφής (return character). Με το πάτημα του πλήκτρου Enter δηλώνουμε ότι τελείωσε η εισαγωγή των δεδμένων από το πληκτρολόγιο. Τότε η πρώτη μέθοδος <code>next()</code>, <code>nextInt()</code>,\r\n        <code>nextDouble</code> κλπ. Που βρίσκεται στο πρόγραμμα λαμβάνει το πρώτο στοιχείο δεδομένων (διακριτικό) , η δεύτερη το δεύτερο κ.ο.κ. Η μέθοδος <code>nextLine()</code> λαμβάνει τα υπόλοιπα των δεδομένων μέχρι το τέλος.\r\n    </p>\r\n    <p>\r\n        <a href=\"./learn.php?level=2&step=exercise#17\">Δες την λυμένη άσκηση</a>\r\n    </p>\r\n</div>', NULL, 2);
INSERT INTO `theory` (`id`, `title`, `description`, `downloadFile`, `level_id`) VALUES
(4, 'Πίνακες και αλφαριθμητικά', '<h3>Πίνακες με μια διάσταση</h3>\r\n<div>\r\n    <p>Σε πολλές σύνθετες εφαρμογές, δημιουργούνται οι ανάγκες χρήσης ομάδων τιμών του ίδιου τύπου. Αντί να οριστεί ξεχωριστή μεταβλητή για καταχώρηση κάθε μίας από τις τιμές αυτού του τύπου , είναι προτιμότερο να δημιουργηθεί μια μεταβλητή με δείκτη ή αλλιώς\r\n        ένας πίνακας (array).</p>\r\n    <p>Τα στοιχεία ενός πίνακα σημειώνονται με κοινό όνομα, το οποίο συνοδεύεται από ένα δείκτη (index ή subscript). Ο δείκτης είναι ένας ακέραιος αριθμός ο οποίος είναι τοποθετημένος μέσα σε αγκύλες.</p>\r\n    <p>Παράδειγμα μονοδιάστατου πίνακα με πέντε στοιχεία και τις τιμές τους φαίνεται παρακάτω</p>\r\n    <table class=\"table table-striped\">\r\n        <tr>\r\n            <td>C[0]</td>\r\n            <td>45</td>\r\n        </tr>\r\n        <tr>\r\n            <td>C[1]</td>\r\n            <td>-32</td>\r\n        </tr>\r\n        <tr>\r\n            <td>C[2]</td>\r\n            <td>7</td>\r\n        </tr>\r\n        <tr>\r\n            <td>C[3]</td>\r\n            <td>111</td>\r\n        </tr>\r\n        <tr>\r\n            <td>C[4]</td>\r\n            <td>0</td>\r\n        </tr>\r\n    </table>\r\n    <p>Μια μεταβλητή με δείκτη (πίνακας) μιας διάστασης μπορεί να θεωρηθεί ως μια στήλη δεδομένων. Το όνομα της μεταβλητής του παραπάνω πίνακα είναι το C και έχει 5 στοιχεία C[0], C[1], C[2], C[3], C[4]. Το πρώτο στοιχείο κάθε πίνακα παίρνει πάντα το δείκτη\r\n        0, ενώ το ν-ωστό παίρνει την τιμή ν-1. Το πλήθος των μεταβλητών που περιλαμβάνει ο πίνακας αποτελεί το μήκος αυτού. Για την δημιουργία ενός πίνακα ακολουθούνται 3 βήματα: δήλωση, καταχώρηση και απόδοση αρχικής τιμής.</p>\r\n</div>\r\n\r\n<h3>H δήλωση ενός πίνακα</h3>\r\n<div>\r\n    <p>\r\n        Όπως για κάθε μεταβλητή έτσι και ο πίνακας πρέπει να έχει συγκεκριμένο τύπο π.χ. byte, int, float, String κ.λ.π. Όλα τα στοιχεία του πίνακα είναι του ίδιου τύπου υποχρεωτικά, δεν μπορεί να υπάρχει σε ένα πίνακα στοιχείο τύπου int και στοιχείο τύπου double.\r\n    </p>\r\n    <p>\r\n        Ένας πίνακας δηλώνεται με τον ίδιο τρόπο που δηλώνεται και μια μεταβλητή. Στη δήλωση του πίνακα , δίπλα στο όνομα της μεταβλητής βάζουμε διπλή αγκύλη [ ] ως πρόθεμα ή επίθεμα, για να δειχθεί ότι η μεταβλητή αυτή είναι πίνακας\r\n    </p>\r\n    <p>\r\n        Παράδειγμα\r\n    </p>\r\n    <table class=\"table table-striped\">\r\n        <tr>\r\n            <td>float[] number; </td>\r\n            <td>float number[];</td>\r\n        </tr>\r\n        <tr>\r\n            <td>int[] c; </td>\r\n            <td>int c[];</td>\r\n        </tr>\r\n        <tr>\r\n            <td>String[] names;</td>\r\n            <td>String names[];</td>\r\n        </tr>\r\n    </table>\r\n</div>\r\n\r\n<h3>H καταχώρηση του πίνακα</h3>\r\n<div>\r\n    <p>Με τον ορισμό ενός πίνακα, γίνετε η δήλωση των στοιχείων τα οποία περιέχει αυτός. Δεν έχουν δημιουργηθεί ή δεσμεύσει κάποιο χώρο στη μνήμη που θα περιέχει αυτά τα στοιχεία. Για να δηλώσουμε στον μεταγλωττιστή ότι ο πίνακας C (ο οποίος έχει οριστεί\r\n        ως int) πρέπει να έχει 5 στοιχεία και να δεσμευτεί αντίστοιχος χώρος γι’ αυτά στην μνήμη , συντάσσεται η εξής φράση <code>C = new int[5]</code></p>\r\n    <p>Μπορούμε να κάνουμε δήλωση και καταχώρηση σε μια πρόταση, όπως <code>int C[] = new int[5]</code> ή <code>int[] C = new int[5]</code></p>\r\n</div>\r\n\r\n<h3>Απόδοση αρχικών τιμών στον πίνακα</h3>\r\n<div>\r\n    <p>Σε έναν πίνακα το κάθε στοιχείο του ,προσδιορίζεται με το όνομα του πίνακα, καθώς και με έναν ακέραιο, οποίος δείχνει την θέση του στοιχείου σε αυτόν τον πίνακα και ονομάζεται δείκτης του πίνακα. Ο δείκτης, παίρνει διαδοχικές τιμές, αρχίζοντας από\r\n        την τιμή μηδέν. Σε έναν πίνακα με όνομα C αποδίδουμε αρχικές τιμές με τον εξής τρόπο</p>\r\n    <xmp>\r\n        C[0] = 3; \r\n        C[1] = -2; \r\n        C[2] = 45; \r\n        C[3] = 0; \r\n        C[4] = 111;\r\n    </xmp>\r\n    <p>Για να τυπωθεί η τιμή του τρίτου στοιχείου του πίνακα υπάρχει ο εξής τρόπος <code>System.out.println(C[2]);</code> Το οποίο φέρνει αποτέλεσμα το 45.</p>\r\n    <p>Αν θέλουμε να ορίσουμε στα στοιχεία του πίνακα C την τιμή 0, γίνεται με τον εξής τρόπο</p>\r\n    <xmp>\r\n        for(int i=0; i<=4; i++){ \r\n            C[i]=0; \r\n        } \r\n    </xmp>\r\n    <p>Ακόμα ένας τρόπος απόδοσης αρχικών τιμών, είναι η τοποθέτησή τους μέσα σε αγκύλες. Παρακάτω αποδίδονται τιμές σε ένα πίνακα τύπου float, ο οποίος έχει επτά στοιχεία</p>\r\n    <p>\r\n        <code>\r\n            float[] numbers = {1.5f, 0.0f, 5.89f, 3.4f, -9.56f, 56.4f, 67.567f};\r\n        </code>\r\n    </p>\r\n    <p>Απόδοση αρχικών τιμών μπορεί να γίνει και με την απόδοση ετέρου πίνακα, για παράδειγμα</p>\r\n    <p><code>float[] numbers1 = numbers;</code></p>\r\n    <p>Έτσι δημιουργούνται δύο μεταβλητές που έχουν δείκτη (πίνακες), οι οποίες δείχνουν στα ίδια στοιχεία της μνήμης. </p>\r\n    <p>Για να ελεγχθεί το πλήθος τον τιμών που διαθέτει ένας πίνακας, γράφετε το όνομα του πίνακα, μια τελεία και στη συνέχεια η λέξη length <code>C.length;</code></p>\r\n    <p>\r\n        <a href=\"./learn.php?level=2&step=exercise#30\">Δες την λυμένη άσκηση</a>\r\n    </p>\r\n</div>\r\n\r\n<h3>Πίνακες πολλών διαστάσεων</h3>\r\n<div>\r\n    <p>Υπάρχουν περιπτώσεις που γίνεται χρήση περισσότερων από μιας διάστασης σε έναν πίνακα. Οι πιο συνηθισμένοι είναι οι πίνακες δύο διαστάσεων (δυσδιάστατοι). Παρακάτω δημιουργείται ένας πίνακας με 5 γραμμές και 4 στήλες </p>\r\n    <table class=\"table table-striped\">\r\n        <tr>\r\n            <th></th>\r\n            <th>Στήλη 0</th>\r\n            <th>Στήλη 1</th>\r\n            <th>Στήλη 2</th>\r\n            <th>Στήλη 3</th>\r\n        </tr>\r\n        <tr>\r\n            <th>Γραμμή 0</th>\r\n            <td>20</td>\r\n            <td>-4</td>\r\n            <td>8</td>\r\n            <td>17</td>\r\n        </tr>\r\n        <tr>\r\n            <th>Γραμμή 1</th>\r\n            <td>45</td>\r\n            <td>9</td>\r\n            <td>-12</td>\r\n            <td>56</td>\r\n        </tr>\r\n        <tr>\r\n            <th>Γραμμή 2</th>\r\n            <td>123</td>\r\n            <td>-14</td>\r\n            <td>7</td>\r\n            <td>89</td>\r\n        </tr>\r\n        <tr>\r\n            <th>Γραμμή 3</th>\r\n            <td>98</td>\r\n            <td>-17</td>\r\n            <td>22</td>\r\n            <td>44</td>\r\n        </tr>\r\n        <tr>\r\n            <th>Γραμμή 4</th>\r\n            <td>33</td>\r\n            <td>10</td>\r\n            <td>45</td>\r\n            <td>39</td>\r\n        </tr>\r\n    </table>\r\n    <p>Για να προσδιοριστεί η θέση του κάθε στοιχείου, χρειάζονται δύο αριθμοί, ένας για την γραμμή και ο άλλος για την στήλη. Έτσι , έστω ότι ονομάζεται ο πίνακας Μ, το στοιχείο Μ[0][2] είναι το νούμερο 8, το στοιχείο Μ[3][3] είναι το νούμερο 44. </p>\r\n    <p>Οι πίνακες πολλών διαστάσεων δηλώνονται, καταχωρίζονται και παίρνουν αρχικές τιμές με τον ίδιο τρόπο που παίρνουν και οι πίνακες μιας διάστασης, με τη χρήση ανάλογου αριθμού ένθετων <code>for</code>. </p>\r\n    <p>\r\n        <a href=\"./learn.php?level=2&step=exercise#31\">Δες την λυμένη άσκηση</a>\r\n    </p>\r\n</div>', NULL, 4),
(3, 'Δομές διακλάδωσης - επαναλήψεις - μέθοδοι', '<h3>Αποφάσεις</h3>\r\n<div>\r\n    <p>Τα προγράμματα που εξετάσαμε έως τώρα εκτελούνται ακολουθιακά, το οποίο σημαίνει ότι μια εντολή διαδέχεται με την σειρά την άλλη, όπως είναι γραμμένες στον κώδικα του προγράμματος. Υπάρχουν όμως περιπτώσεις που χρειάζεται να πάρουμε αποφάσεις όπως\r\n        για παράδειγμα “αν φθάνουν τα χρήματα αγοράστε το αυτοκίνητο Α, αλλιώς πάρε το αυτοκίνητο Β”. Στην προγραμματιστική λογική, αυτό μεταφράζεται με το να κάνουμε κάποιες συγκρίσεις μεταξύ μεταβλητών, ή να υπολογίσουμε την τιμή κάποιας έκφρασης και\r\n        ανάλογα με το αποτέλεσμα να εκτελέσουμε αυτή ή εκείνη την ομάδα εντολών. Σε όλα σχεδόν τα προγράμματα φθάνουμε σε ένα σημείο που πρέπει να ληφθεί μια απόφαση. Σε εκείνο το σημείο διακόπτεται η κανονική ροή του προγράμματος και ανάλογα με την τιμή\r\n        μια έκφρασης πραγματοποιείται μια διακλάδωση υπό συνθήκη (conditional branching). Εκτός από τις διακλαδώσεις (άλματα) που πραγματοποιούνται με συνθήκη υπάρχουν και μερικές διακλαδώσεις που πραγματοποιούνται χωρίς συνθήκη (unconditional branching).\r\n    </p>\r\n</div>\r\n\r\n<h3>Η δομή if</h3>\r\n<div>\r\n    <p>\r\n        Η πιο συνηθισμένη από τις δομές διακλάδωσης είναι η if, η οποία στην πιο απλή μορφή της αποδίδεται με το παρακάτω διάγραμμα\r\n    </p>\r\n    <img src=\"/letsLearnJava/images/if1.png\" alt=\"if\" />\r\n    <p>Στα λογικά διαγράμματα, ο ρόμβος χρησιμοποιείται για να αναπαρασταθεί η δομή if, ενώ η εκτέλεση κάποιας ενέργειας (πράξη, εκχώρηση τιμής κ.λ.π.), αναπαρίσταται με ένα ορθογώνιο. Οι εντολές εισόδου-εξόδου αναπαρίστανται με ένα πλάγιο παραλληλόγραμμο.\r\n        <ul>\r\n            <li>\r\n                Αν η συνθήκη είναι αληθής (true), τότε γίνεται εκτέλεση της εντολής Α και στη συνέχεια το πρόγραμμα προχωρά και εκτελεί την επόμενη εντολή που υπάρχει.\r\n            </li>\r\n            <li>\r\n                Αν η συνθήκη είναι ψευδή (false) τότε το πρόγραμμα προχωράει απ’ ευθείας στην εντολή Β.\r\n            </li>\r\n        </ul>\r\n    </p>\r\n    <p>Στο παρακάτω παράδειγμα όταν ο βαθμός του φοιτητή είναι ίσος ή μεγαλύτερος του 5, τυπώνεται το μήνυμα “πέρασε το μάθημα” </p>\r\n    <img src=\"/letsLearnJava/images/if2.png\" alt=\"if\" />\r\n    <p>Αυτό σε Java κώδικα γράφεται </p>\r\n    <xmp>\r\n        If (grade >= 5) <\r\n            System.out.println(\"You have passed\"); \r\n    </xmp>\r\n    <p>Το if εξετάζει αν η τιμή που έχει η μεταβλητή grade είναι μεγαλύτερη ή ίση του 5 και αν αυτό ισχύει τότε τυπώνει το μήνυμα \"You have passed\". Αν θέλουμε να εκτελέσουμε πολλές εντολές όταν μια συνθήκη είναι αληθής, τις τοποθετούμε μέσα σε αγκύλες <code>{}</code>.\r\n    </p>\r\n    <xmp>\r\n        If (συνθήκη) { \r\n            Εντολή 1; \r\n            Εντολή 2; \r\n            ………… \r\n        }\r\n\r\n        If (συνθήκη) \r\n            Εντολή 1; \r\n        Εντολή 2; \r\n        …………\r\n    </xmp>\r\n    <p>Στην πρώτη περίπτωση αν η συνθήκη είναι αληθής θα εκτελεστούν όλες οι εντολές που υπάρχουν μέσα στις αγκύλες. Στην δεύτερη περίπτωση μόνο η εντολή 1.</p>\r\n</div>\r\n\r\n<h3>Ο όρος else</h3>\r\n<div>\r\n    <p>\r\n        Υπάρχουν ορισμένες περιπτώσεις που πρέπει να αποφασίσουμε τι θα συμβεί αν δεν ισχύσει η συνθήκη που ακολουθεί το\r\n        <code>if</code>. Τότε χρησιμοποιούμε την <code>else</code>. Το λογικό διάγραμμα και η σύνταξη της if…else βρίσκεται παρακάτω\r\n    </p>\r\n    <img src=\"/letsLearnJava/images/else1.png\" alt=\"else\"/>\r\n    <p>Χρησιμοποιώντας το else, το παράδειγμα της προηγούμενης παραγράφου γίνεται</p>\r\n    <img src=\"/letsLearnJava/images/else2.png\" alt=\"else\" />\r\n    <p>Και ο αντίστοιχος κώδικας σε Java είναι </p>\r\n    <xmp>\r\n        if (grade >=5) \r\n            System.out.println(\"You have passed\"); \r\n        else \r\n            System.out.println(\"You have failed\");\r\n    </xmp>\r\n    <p>\r\n        <a href=\"./learn.php?level=3&step=exercise#18\">Δες την λυμένη άσκηση</a>\r\n    </p>\r\n</div>\r\n\r\n<h3>Ένθετα if</h3>\r\n<div>\r\n    <p>\r\n        Σε αρκετές περιπτώσεις η εκτέλεση του if ή του else μπορεί να οδηγήσει σε ακόμα ένα if, το οποίο ονομάζεται ένθετο if(nested). Ένα nested if μπορεί να περιέχει και εκείνο με την σειρά του ακόμα ένα nested if. Για τέτοιες περιπτώσεις, κάθε else ανήκει\r\n        στο πλησιέστερο if.\r\n    </p>\r\n    <p>\r\n        <a href=\"./learn.php?level=3&step=exercise#19\">Δες την λυμένη άσκηση</a>\r\n    </p>\r\n    <p>\r\n        <a href=\"./learn.php?level=3&step=exercise#20\">Δες την λυμένη άσκηση</a>\r\n    </p>\r\n</div>\r\n\r\n<h3>Οι τελεστές & και |</h3>\r\n<div>\r\n    <p>Ο τελεστής <code>&&</code> ονομάζεται υπό συνθήκη AND (conditional AND), ενώ υπάρχει και ο τελεστής\r\n        <code>&</code> ο οποίος ονομάζεται λογικό AND (logical AND). Το αποτέλεσμά τους είναι ίδιο, με μία μόνο διαφορά που φαίνεται παρακάτω\r\n        <ul>\r\n            <li><code>x==5 && y>=12</code></li>\r\n            <li><code>x==5 & y>=12</code></li>\r\n        </ul>\r\n        Για τιμές <code>x=4</code>, <code>y=13</code>, οι παραπάνω συνθήκες δίνουν αποτέλεσμα ψευδές.\r\n    </p>\r\n    <p>Στην περίπτωση Α εξετάζεται η πρώτη συνθήκη <code>x==5</code> και βρίσκεται ψευδής διότι το x είναι 4. Αφού η συνθήκη αριστερά του τελεστή <code>&&</code> είναι ψευδής, η συνθήκη <code>y>=12</code>, δεν εξετάζεται καθόλου και το αποτέλεσμα είναι ψευδές.\r\n        Αποφεύγοντας την εξέταση της δεύτερης συνθήκης ο κώδικας γίνεται ταχύτερος.\r\n    </p>\r\n    <p>Στην περίπτωση Β εξετάζεται η συνθήκη <code>x==5</code> η οποία βρίσκεται ψευδής. Στη συνέχεια εξετάζεται η δεύτερη συνθήκη η οποία βρίσκεται αληθής αφού το <code>y=13</code>. Το τελικό αποτέλεσμα είναι πάλι ψευδές διότι\r\n        <code>false + true = false</code>. Εκ πρώτης όψεως η εξέταση της πρώτης συνθήκης φαίνεται περιττή, υπάρχουν όμως μερικές περιπτώσεις όπου ο τελεστής <code>&</code> είναι χρήσιμος, κυρίως όταν έχουμε μεταβολή της τιμής μιας μεταβλητής. </p>\r\n    <p>\r\n        Αν δηλαδή είχαμε τις συνθήκες\r\n        <ul>\r\n            <li><code>x==5 && ++y>=12</code></li>\r\n            <li><code>x==5 & ++y>=12</code></li>\r\n        </ul>\r\n        Τότε χρειάζεται αν χρησιμοποιηθεί ο τελεστής <code>&</code> και όχι ο <code>&&</code>, για να εξασφαλιστεί ότι θα εξεταστεί και η δεύτερη συνθήκη διότι έχουμε μεταβαλλόμενες μεταβλητές.\r\n    </p>\r\n    <p>\r\n        Ανάλογα χρησιμοποιείται και ο τελεστής <code>|</code>, ο οποίος λέγεται λογικό OR (logical OR) σε αντιδιαστολή με το υπό συνθήκη OR (conditional OR) που είναι ο τελεστής <code>||</code>.\r\n    </p>\r\n</div>\r\n\r\n<h3>Ο τριαδικός τελεστής ?:</h3>\r\n<div>\r\n    <p>\r\n        Ο τελεστής υπόθεσής <code>?:</code> (ή αλλιώς τριαδικός) εμπλέκει τρεις τελεστές. Παράδειγμα\r\n    </p>\r\n    <xmp>\r\n        if (a>b) \r\n            Max=a; \r\n        else \r\n            Max=b;\r\n    </xmp>\r\n    <p>\r\n        Ο παραπάνω κώδικας με την χρήση του τριαδικού τελεστή γίνεται\r\n        <code>Max = a > b ? a : b;</code>\r\n    </p>\r\n    <p>\r\n        <a href=\"./learn.php?level=3&step=exercise#21\">Δες την λυμένη άσκηση</a>\r\n    </p>\r\n</div>\r\n\r\n<h3>Η δομή πολλαπλής διακλάδωσης switch</h3>\r\n<div>\r\n    <p>\r\n        Σε ορισμένες περιπτώσεις πρέπει να ελέγξουμε την τιμή μιας μεταβλητής η οποία έχει την δυνατότητα να πάρει διάφορες τιμές και ανάλογα να εκτελέσει μια σειρά από ενέργειες. Μπορούμε να υλοποιήσουμε την κατάσταση αυτή και με μια σειρά από if, else..if,\r\n        else..if, μπορούμε πιο βολικά να χρησιμοποιήσουμε την δομή πολλαπλής διακλάδωσης switch. Στη δομή αυτή εξετάζουμε μια μεταβλητή ή μια έκφραση η οποία μπορεί να πάρει διάφορες τιμές. Το λογικό διάγραμμα τα πολλαπλής διακλάδωσης switch είναι\r\n    </p>\r\n    <img src=\"/letsLearnJava/images/switch.png\" alt=\"switch\" /> \r\n    <p>\r\n        <a href=\"./learn.php?level=3&step=exercise#22\">Δες την λυμένη άσκηση</a>\r\n    </p>\r\n</div>\r\n\r\n<h3>Εντολές επανάληψης - βρόγχοι</h3>\r\n<div>\r\n    <p>Βρόγχος επανάληψης είναι μια δομή που μας επιτρέπει να επαναλάβουμε μια σειρά από εντολές. Στις επαναλήψεις υπάρχουν δύο περιπτώσεις. Είτε να γνωρίζουμε εκ των προτέρων τον αριθμό των επαναλήψεων που πρέπει αν γίνουν χρησιμοποιώντας έτσι τον βρόγχο\r\n        <code>for</code>, είτε να μην γνωρίζουμε τον ακριβή αριθμό των επαναλήψεων όπου χρησιμοποιούμε τους βρόγχους <code>while</code> ή <code>do-while</code> . Στη δεύτερη περίπτωση οι εντολές επαναλαμβάνονται εφόσον ισχύει μια λογική συνθήκη , ενώ\r\n        ο βρόγχος σταματά όταν η συνθήκη αυτή γίνεται ψευδής.\r\n    </p>\r\n</div>\r\n\r\n\r\n<h3>Ο βρόγχος for</h3>\r\n<div>\r\n    <p>Ο βρόγχος <code>for</code> έχει μια συνθήκη η οποία περιέχει συνήθως ένα μετρητή, ο οποίος μπορεί να μεταβάλλεται προς τα πάνω ή προς τα κάτω. Η εκτέλεση των εντολών που γίνονται μέσα στον βρόγχο είναι εφ’ όσον ο μετρητής επαληθεύει την συνθήκη, όταν\r\n        σταματήσει να την επαληθεύει τότε σταματάει και η εκτέλεση των εντολών. </p>\r\n    <img src=\"/letsLearnJava/images/for.png\" alt=\"switch\" />\r\n    <p>Η σύνταξη του βρόγχου <code>for</code> είναι</p>\r\n    <xmp>\r\n        for (Εκφραση1; Έκφραση2; Έκφραση3) Εντολή(ες);\r\n    </xmp>\r\n    <p>Η έκφραση1 και έκφραση3 μπορούν να είναι οποιεσδήποτε παραστάσεις, η έκφραση2 είναι οπωσδήποτε μια λογική έκφραση, και η εντολή(ες) μπορεί να είναι μια απλή εντολή ή μια ομάδα από εντολές. Για παράδειγμα\r\n        <code>for(int c=1; c<=10; c++)</code>\r\n    </p>\r\n    <p> Οι τρείς εκφράσεις έχουν την εξής χρησιμότητα στον βρόγχο.\r\n        <ul>\r\n            <li> Η πρώτη έκφραση δίνει την αρχική τιμή στην μεταβλητή .\r\n            </li>\r\n            <li> Η δεύτερη έκφραση χρησιμοποιείται για να ελέγχετε αν είναι αληθές ο βρόγχος ώστε να συνεχίζει ή να τερματίζει ο βρόγχος.</li>\r\n            <li> Η τρίτη έκφραση καθορίζει το βήμα της επανάληψης.\r\n            </li>\r\n        </ul>\r\n        Παράδειγμα\r\n    </p>   \r\n    <xmp>\r\n        public static void main(String[] args) { \r\n            byte iVar=1; \r\n            for(int i=0; i<9; i++){ \r\n                iVar*=2; \r\n                System.out.println(iVar); \r\n            } \r\n        } \r\n    </xmp>\r\n        <p>\r\n            Στο βρόγχο <code>for</code>, μέσα στη παρένθεση ορίζεται η ακεραία μεταβλητή <code>i</code>, η οποία παίρνει αρχική τιμή μηδέν int <code>i=0;</code>. Η Τρίτη έκφραση εξασφαλίζει το να αυξάνεται ο μετρητής κατά 1 ύστερα από την εκτέλεση\r\n            κάθε επανάληψης. <code>i++</code>. Για να εκτελεστούν οι εντολές που βρίσκονται εντός του βρόγχου , πρέπει αν ισχύει <code>i<8</code>. Τα παραπάνω δείχνουν ότι ο βρόγχος θα εκτελεστεί 8 φορές. Οι εντολές που βρίσκονται στο σώμα του βρόγχου\r\n            και επαναλαμβάνονται είναι οι\r\n            <ul>\r\n                <li>iVar *=2;</li>\r\n                <li>System.out.println(iVar);</li>\r\n            </ul>\r\n            Οι εντολές αυτές εσωκλείονται με άγκιστρα <code>{ }</code>. Τα άγκιστρα μπαίνουν αν υπάρχουν δύο ή και περισσότερες εντολές μέσα στο βρόγχο. \r\n    </p>\r\n    <p>\r\n        <a href=\"./learn.php?level=3&step=exercise#23\">Δες την λυμένη άσκηση</a>\r\n    </p>\r\n</div>\r\n\r\n\r\n<h3>Ο βρόγχος while</h3>\r\n<div>\r\n    <p>Η δομή αυτή δημιουργεί την επανάληψη μίας ή περισσοτέρων εντολών, με την διαφορά από το <code>for</code> ότι ο αριθμός των επαναλήψεων δεν είναι προκαθορισμένος αλλά εξαρτάται από μια συνθήκη. Αν η συνθήκη αυτή είναι αληθής ο βρόγχος εξακολουθεί να\r\n        εκτελείται, αλλιώς σταματάει να εκτελείται και συνεχίζει το πρόγραμμα με τις επόμενες εντολές. Αν η συνθήκη του βρόγχου βρεθεί ψευδής στην αρχή της, τότε δεν θα εκτελεστεί καμία φορά ο βρόγχος. </p>\r\n    <img src=\"/letsLearnJava/images/while.png\" alt=\"switch\" />\r\n    <p>Εφόσον ο βρόγχος περιλαμβάνει μόνο μια εντολή δεν χρειάζεται να τοποθετηθούν άγκιστρα. </p>\r\n    <p>\r\n        <a href=\"./learn.php?level=3&step=exercise#24\">Δες την λυμένη άσκηση</a>\r\n    </p>\r\n</div>\r\n\r\n\r\n<h3>Ο βρόγχος do-while</h3>\r\n<div>\r\n    <p>Ο βρόγχος <code>do-while</code> είναι παρόμοιος με τον βρόγχο <code>while</code>, με την μόνη διαφορά ότι η συνθήκη δεν ελέγχετε στην αρχή του βρόγχου αλλά στο τέλος. Με αυτό τον τρόπο ο βρόγχος εκτελείτε τουλάχιστον μια φορά ακόμα και αν η λογική\r\n        συνθήκη είναι ψευδής. </p>\r\n    <img src=\"/letsLearnJava/images/dowhile.png\" alt=\"switch\" /> \r\n    <p>\r\n        <a href=\"./learn.php?level=3&step=exercise#25\">Δες την λυμένη άσκηση</a>\r\n    </p>\r\n</div>\r\n\r\n<h3>Ένθετοι βρόγχοι</h3>\r\n<div>\r\n    <p>\r\n        Μπορούμε μερικές φορές να προσθέσουμε έναν βρόγχο μέσα σε έναν άλλο (nesting) προσέχοντας τα παρακάτω\r\n        <ol>\r\n            <li>Ο εσωτερικός βρόγχος πρέπει να περιέχετε ολόκληρος στον εξωτερικό. </li>\r\n            <li>Δεν μπαίνουμε στο εσωτερικό ενός βρόγχου αν δεν περάσουμε από την πρώτη εντολή του.</li>\r\n            <li>Δεν γίνετε χρήση της ίδιας μεταβλητής ως απαριθμητής σε δύο η περισσότερους βρόγχους, όπου ο ένας εμπεριέχει τον άλλο. </li>\r\n        </ol>\r\n    </p>\r\n    <p>\r\n        <a href=\"./learn.php?level=3&step=exercise#26\">Δες την λυμένη άσκηση</a>\r\n    </p>\r\n</div>\r\n\r\n<h3>Η εντολή continue</h3>\r\n<div>\r\n    <p>\r\n        Σε μερικές περιπτώσεις για να αποφευχθεί να χρησιμοποιηθεί μια τιμή ενός βρόχου κάνουμε χρήση της εντολής\r\n        <code>continue</code>. Έστω ότι πρέπει να υπολογιστεί το άθροισμα των αριθμών από το 1 μέχρι το 10, εκτός από τα νούμερα 4 και 8. Αυτό γίνεται με τον παρακάτω τρόπο\r\n    </p>\r\n    <xmp>\r\n        public static void main(String[] args) { \r\n            int sum=0; \r\n            for(int i=1; i<=10; i++) { \r\n                if(i==4 | i==8) \r\n                    continue; \r\n                System.out.println(i); \r\n                sum=sum+i; \r\n            } \r\n            System.out.println( \"The sum is\" + sum); \r\n        } \r\n    </xmp>\r\n    <p>Σε περιπτώσεις ένθετων βρόγχων αν χρειαστεί να αποφύγουμε των εσωτερικό, χρησιμοποιούμε την συνθήκη\r\n                <code>continue</code> με ετικέτα (label). \r\n    </p>\r\n    <p>\r\n        <a href=\"./learn.php?level=3&step=exercise#27\">Δες την λυμένη άσκηση</a>\r\n    </p>\r\n</div>\r\n\r\n<h3>Η χρήση του break σε έναν βρόγχο</h3>\r\n<div>\r\n    <p>\r\n        Η εντολή break χρησιμοποιείται για την έξοδο από έναν βρόγχο.     \r\n    </p>\r\n    <xmp>\r\n        public class prime {\r\n\r\n            public static void main(String[] args) {\r\n                int ubound = 30;\r\n                boolean flag;\r\n                \r\n                for (int i = 1; i <= ubound; ++i) {\r\n                    flag = true;\r\n                    for (int k = 2; k < i; ++k) {\r\n                        if (i % k == 0) {\r\n                            flag = false;\r\n                            break;\r\n                        }\r\n                    }\r\n                    if (flag) {\r\n                        System.out.println(i);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    </xmp>\r\n    <xmp>\r\n        public class showbreak {\r\n\r\n            public static void main(String[] args) {\r\n                for (int i = 1; i < 10; i++) {\r\n                    for (int j = 1; j < 10; j++) {\r\n                        if (j == 2) {\r\n                            break;\r\n                        }\r\n                        System.out.println(i + \",\" + j);\r\n                    }\r\n                }\r\n            }\r\n        }        \r\n    </xmp>\r\n</div>\r\n\r\n\r\n<h3>Μέθοδοι</h3>\r\n<div>\r\n    <p>\r\n        Ο καλύτερος τρόπος για την κατασκευή και την συντήρηση ενός προγράμματος είναι η δημιουργία ενός προγράμματος με την χρήση πολλών και μικρών κομματιών κώδικα. Τα κομματάκια αυτά ονομάζονται και ως μονάδες (modules). Στην Java γίνεται κατασκευή μονάδων\r\n        με την χρήση μεθόδων (methods) και κλάσεων (class).\r\n    </p>\r\n    <p>\r\n        Με το όρο μέθοδος (method) νοείται ένα σύνολο από δηλώσεις και εντολές οι οποίες ομαδοποιούνται ώστε να αποτελέσουν ένα mini-πρόγραμμα. Σε άλλες γλώσσες προγραμματισμού οι μέθοδοι ονομάζονται συναρτήσεις (functions), διαδικασίες (procedures), υπορουτίνες\r\n        (subroutines) ή υποπρογράμματα (subprograms).\r\n    </p>\r\n    <p>Ο τρόπος δήλωσης μιας μεθόδου είναι ο εξής </p>\r\n    <xmp>\r\n        Τιμή_επιστροφής όνομα_μεθόδου (λίστα παραμέτρων) { Δηλώσεις και εντολές }\r\n    </xmp>\r\n    <ul>\r\n        <li>Το όνομα της μεθόδου μπορεί να είναι οποιοδήποτε έγκυρο όνομα. </li>\r\n        <li>Η τιμή επιστροφής είναι ο τύπος δεδομένων που επιστρέφει αυτή η μέθοδος. Άμα η μέθοδος δεν επιστρέφει κάποια τιμή, τότε στην θέση της τιμής_επιστροφής μπαίνει η λέξη <code>void</code>. Οι δηλώσεις αλλά και οι εντολές που υπάρχουν σε κάθε μέθοδο\r\n            περικλείονται από άγκιστρα. </li>\r\n    </ul>\r\n    <p>Για να καλέσει κάποιος χρήστης την μέθοδο, γράφει απλά το όνομά της στο σημείο που την χρειάζεται και μόλις τελειώσει η μέθοδος, το πρόγραμμα συνεχίζει από εκείνο το σημείο που έγινε η κλήση της μεθόδου. Να η μέθοδος δεν επιστρέφει κάποιο αποτέλεσμα,\r\n        η επιστροφή στο κυρίως πρόγραμμα γίνεται μετά το δεξιό άγκιστρο ή με την κλήση της εντολής <code>return;</code></p>\r\n    <p>Εάν η μέθοδος επιστρέφει κάποιο αποτέλεσμα, η επιστροφή στο κυρίως πρόγραμμα γίνεται με την εντολή\r\n        <code>return εκφραση;</code></p>\r\n    <p>Οι μεταβλητές που δηλώνονται σε μια μέθοδο θεωρούνται τοπικές μεταβλητές (local variables). Οι τοπικές μεταβλητές ορίζονται μόνο μέσα στο εσωτερικό της μεθόδου στην οποία δηλώνονται, χρησιμοποιούνται μόνο μέσα στη μέθοδο και στη συνέχεια παύουν να\r\n        υφίστανται. Στις τοπικές τιμές είναι ευθύνη του προγραμματιστή να δώσει αρχική τιμή στις μεταβλητές αυτές καθότι δεν τους αποδίδει αρχική τιμή το πρόγραμμα από μόνο του. </p>\r\n    <p>\r\n        <a href=\"./learn.php?level=3&step=exercise#28\">Δες την λυμένη άσκηση</a>\r\n    </p>\r\n    <p>\r\n        <a href=\"./learn.php?level=3&step=exercise#29\">Δες την λυμένη άσκηση</a>\r\n    </p>\r\n</div>', NULL, 3);
INSERT INTO `theory` (`id`, `title`, `description`, `downloadFile`, `level_id`) VALUES
(5, 'Κλάσεις και αντικείμενα', '<h3>Κλάσεις και αντικείμενα</h3>\r\n<div>\r\n    <p>\r\n        Οι έννοιες της κλάσης και του αντικειμένου, είναι βασικές έννοιες για τον αντικειμενοστραφή προγραμματισμό. Η  κλάση είναι μια γενική φόρμα που χρησιμοποιείται για την κατασκευή αντικειμένων, τα οποία έχουν παρόμοια χαρακτηρίστηκα μεταξύ τους. Όταν ορίσουμε\r\n        την κλάση μπορούμε να χρησιμοποιήσουμε τον ορισμό της για την δημιουργία αντικειμένων. Κάθε τέτοιο αντικείμενο, ονομάζεται και στιγμιότυπο της κλάσης.\r\n    </p>\r\n    <p>\r\n        Παράδειγμα: Έστω ότι έχουμε την κλάση «δέντρο» και διάφορα αντικείμενα της κλάσης αυτής «μηλιά», «λεμονιά», «έλατο» κ.λ.π. Όλα τα αντικείμενα έχουν τα κύρια χαρακτηρίστηκα της κλάσης δέντρο (ρίζα, κορμός, κλαδιά, φύλλα), όμως το κάθε ένα αντικείμενο έχει\r\n        και τις δικές του ιδιότητας όπως, το είδος του καρπού, το σχήμα, αν είναι φυλλοβόλο κ.λ.π.\r\n    </p>\r\n    <p>\r\n        Παράδειγμα: Σε πολλές εφαρμογές χρησιμοποιούνται κουμπιά Buttons. Στη Java, υπάρχει έτοιμη κλάση Button, η οποία καθορίζει μερικά γενικά χαρακτηρίστηκα που πρέπει να έχει ένα κουμπί, όπως το μέγεθός του, την ετικέτα του, το πως θα ανταποκρίνεται (διπλό\r\n        ή μονό πάτημα) κ.λ.π. Με βάση την κλάση Button, μπορούμε να δημιουργήσουμε αντικείμενα τα οποία να έχουν όλες τις παραπάνω ιδιότητες της κλάσης Button, αλλά να διαθέτουν και δικά τους μοναδικά χαρακτηρίστηκα.\r\n    </p>\r\n    <p>\r\n        Στην Java υπάρχουν έτοιμες κλάσεις, όμως ο κάθε χρήστης να δημιουργήσει δικές του κλάσεις. Τα βασικά συστατικά που πρέπει να συμπεριλαμβάνονται σε μια κλάση είναι:\r\n        <ul>\r\n            <li>Οι μεταβλητές (variables), που διαφοροποιούν το ένα αντικείμενο της κλάσης από το άλλο</li>\r\n            <li>Οι μέθοδοι (methods), οι οποίες καθορίζουν το τι μπορούμε να κάνουμε στα αντικείμενα ή με τα αντικείμενα. Η μέθοδος είναι δηλώσεις και εντολές που εκτελούν μια λειτουργία του αντικειμένου.</li>\r\n        </ul>\r\n    </p>\r\n</div>\r\n\r\n<h3>Πως ορίζεται μια κλάση</h3>\r\n<div>\r\n    <p>Ο ορισμός της κλάσης γίνεται με την λέξη class, η οποία ακολουθείται από το όνομα που θέλουμε να δώσουμε στην κλάση αυτή. Παρακάτω φαίνεται η δημιουργία μιας απλής κλάσης</p>\r\n    <xmp>\r\n        class myClass{ \r\n\r\n        } \r\n    </xmp>\r\n    <p>Η προηγούμενη είναι μια κλάση της Java. Μπορούμε να την μεταγλωττίσουμε χωρίς όμως να φέρει κάποιο αποτέλεσμα γιατί δεν της έχουμε δώσει τέτοια χαρακτηρίστηκα. </p>\r\n    <p>Παρακάτω ορίζεται η κλάση Circle, η οποία θα χρησιμοποιηθεί για την δημιουργία κυκλικών αντικειμένων. </p>\r\n    <xmp>\r\n        class Circle {\r\n\r\n            static double Pi = 3.14; //o arithmos π \r\n            static int count = 0;\r\n        \r\n            double radius; //h aktina tou kyklou \r\n            double x;  //h tetmimeni tou kedrou \r\n            double j;  //h tetagmeni tou kedrou \r\n        }\r\n    </xmp>\r\n    <p>\r\n        Στην κλάση αυτή έχουν οριστεί πέντε μεταβλητές <code>Pi</code>, <code>count</code>, <code>radius</code>, <code>x</code>, <code>y</code>. Οι μεταβλητές αυτές ανήκουν σε ξεχωριστές κατηγορίες.\r\n        <ul>\r\n            <li>\r\n                Στην πρώτη κατηγορία υπάρχουν οι μεταβλητές Pi και count, οι οποίες θεωρούνται μεταβλητές κλάσης (class variable) και έχουν δηλωθεί με την λέξη static. Αυτές οι μεταβλητές υπάρχουν στην κλάση, ακόμα και αν δεν χρησιμοποιούνται από αυτή. Αν αλλάξουν οι αρχικές τιμές τους, τότε αλλάζουν και οι τιμές σε όλα τα αντικείμενα που τις χρησιμοποιούν.\r\n            </li>\r\n            <li>\r\n                Στην δεύτερη  κατηγορία υπάρχουν οι μεταβλητές x, y και radius. Αυτές λέγονται μεταβλητές στιγμιότυπου (instance variables). Αυτές οι μεταβλητές υπάρχουν σε κάθε αντικείμενο της κλάσης που δημιουργείται, όμως παίρνουν διαφορετικές τιμές από αντικείμενο σε αντικείμενο. Μια μεταβλητή στιγμιότυπου, δηλώνεται με το είδος του τύπου  και το όνομά της.\r\n            </li>\r\n        </ul>\r\n    </p>\r\n    <p>Αναλόγως την μεταβλητή, υπάρχουν δύο κατηγορίες μεθόδων.  \r\n        <ul>\r\n            <li>Η πρώτη είναι η μέθοδος κλάσης(class method). Η συγκεκριμένη δηλώνεται με την λέξη static και μπορεί να εκτελεστεί άσχετα αν υπάρχει αντικείμενο της κλάσης ή όχι.</li>\r\n            <li>Η δεύτερη είναι η μέθοδος στιγμιότυπου, η οποία για να εκτελεστεί, πρέπει να υπάρχουν αντικείμενα της κλάσης. Αν δεν υπάρχει αντικείμενο δεν υπάρχει νόημα να εκτελεστεί αυτή η μέθοδος. </li>\r\n        </ul>\r\n        Η δομή της μεθόδου είναι η εξής \r\n    </p>\r\n    <xmp>\r\n        Τύπος όνομα_μεθόδου (όρισμα1, όρισμα2, … , όρισμα ν) \r\n        { \r\n            Κώδικας προς εκτέλεση \r\n        } \r\n    </xmp>\r\n    <p>\r\n        <ul>\r\n            <li>Ο τύπος μας δείχνει την τιμή που επιστρέφει μια μέθοδος. Μπορεί να είναι ακόμα και μια άλλη κλάση. Αν δεν επιστρέφει τίποτα στην θέση του τύπου βάζουμε την λέξη <code>void</code>.</li>\r\n            <li>Το όνομα της μεθόδου το καθορίζεται από εμάς καθώς και τα ορίσματα που θα περιλαμβάνονται. Αν δεν υπάρχουν ορίσματα , τοποθετούνται απλός παρενθέσεις.</li>\r\n            <li>Για να επιστρέψει μια τιμή από κάποια μέθοδο, πρέπει να γίνει χρήση της εντολής return. </li>\r\n            <li>Για να γίνει αναφορά στις μεταβλητές και τις μεθόδους που περιέχει ένα αντικείμενο χρησιμοποιούμε τον τελεστή <code>.</code></li>\r\n        </ul>\r\n    </p>\r\n    <p>\r\n        Σύμφωνα με προηγούμενο παράδειγμα της κλάσης <code>Circle</code>, ορίζουμε δύο μεθόδους, \r\n        <ul>\r\n            <li>μια μέθοδο κλάσης <code>countCircle()</code>, που θα μετρά τα αντικείμενα κύκλους που δημιουργούνται και μια μέθοδο στιγμιότυπου</li>\r\n            <li>την <code>area()</code>, η οποία θα υπολογίζει για κάθε κύκλο το εμβαδόν του.</li>\r\n        </ul>    \r\n    </p>\r\n    <xmp>\r\n        static int countCircle() {\r\n            return count;\r\n        }\r\n    \r\n        double area() {\r\n            return Pi * radius * radius;\r\n        }\r\n    </xmp>\r\n</div>\r\n\r\n<h3>Η μεταβλητή this</h3>\r\n<div>\r\n    <p>Για κάθε μέθοδο στιγμιότυπου, υπάρχει μια αναφορά που ονομάζεται this και αναφέρεται στο τρέχον αντικείμενο που έχει κληθεί η μέθοδος. Στα προηγούμενα παραδείγματα, όταν η μέθοδος <code>area()</code> αναφέρεται στη μεταβλητή <code>radius</code>, ο μεταγλωττιστής της Java θα βάλει το αντικείμενο <code>this</code>, ώστε να ισοδυναμεί με το <code>this.radius</code>. Αν και μπορεί να υπάρχουν πολλά αντικείμενα τα οποία να προέρχονται από μια κλάση, στην μνήμη κάθε φορά υπάρχει μόνο ένα αντίγραφο της μεθόδου. Έτσι κάνοντας χρήση της λέξης </code>this</code>, κάνουμε την μέθοδο να εργάζεται κάθε φορά για ένα διαφορετικό αντικείμενο, το οποίο βρίσκεται στην μνήμη εκείνη την στιγμή. Επειδή το <code>this</code> αναφέρεται μόνο στο τρέχον αντικείμενο της κλάσης, μπορεί να χρησιμοποιηθεί μόνο σε μεθόδους στιγμιότυπου και όχι σε μεθόδους κλάσης.  </p>\r\n</div>\r\n\r\n\r\n<h3>Οι κατασκευαστές - Constructors</h3>\r\n<div>\r\n    <p>Οι κατασκευαστές, είναι ειδικές μέθοδοι, οι οποίες πρέπει να υπάρχουν στον ορισμό μιας κλάσης. Οι κατασκευαστές έχουν ίδιο όνομα με το όνομα της κλάσης. Η χρήση τους γίνεται για να δώσουν αρχικές τιμές στης μεταβλητές ενός νέου αντικειμένου αλλά και να κάνει όποιες ενέργειες χρειάζονται για την σωστή ετοιμασία του νέου αντικειμένου. Τα δύο χαρακτηριστικά που διαφοροποιούν τον κατασκευαστή από τις υπόλοιπες μεθόδους είναι:\r\n        <ul>\r\n            <li>Δεν επιστρέφουν ποτέ τιμή, δεν μπαίνει μπροστά του τύπος επιστροφής, ούτε και η λέξη <code>void</code>.</li>\r\n            <li>Έχει ίδιο όνομα με την κλάση</li>\r\n        </ul>\r\n        Παρακάτω δημιουργείται ένας κατασκευαστής για την κλάση <code></code>Circle</code>\r\n    </p>\r\n    <xmp>\r\n        class Circle {\r\n\r\n            static double Pi = 3.14;\r\n            static int count = 0;\r\n            double radius;\r\n            double x;\r\n            double y;\r\n        \r\n            //dimiourgia kataskeuasti \r\n            Circle(double r1, double x1, double y1) {\r\n                radius = r1;\r\n                x = x1;\r\n                y = y1;\r\n                ++count;\r\n            }\r\n        \r\n            double area() {\r\n                return Pi * radius * radius;\r\n            }\r\n        }\r\n    </xmp>\r\n    <p>Ένας κατασκευαστής μπορεί να έχει από καμία, έως όσες παραμέτρους χρειάζεται. Ακόμα σε μια κλάση, μπορούν να υπάρχουν περισσότεροι του ενός κατασκευαστές, που να έχουν διαφορετικές παραμέτρους.  Αν για μια κλάση δεν δημιουργηθεί κατασκευαστής, η Java δημιουργεί από μόνη της και αυτός ο κατασκευαστής δεν κάνει τίποτα.  </p>\r\n    <b>Χρησιμότητα κατασκευαστή</b>\r\n    <p>Το πρόγραμμα που δημιουργήθηκε προηγουμένως είναι ορισμός μιας κλάσης. Αν θέλουμε να δημιουργήσουμε αντικείμενο αυτής της  κλάσης, χρειάζεται να ορίσουμε μια μεταβλητή η οποία θα αποτελεί αναφορά (reference) προς τα αντικείμενο της κλάσης και επίσης τον τελεστή <code>new</code> μαζί με έναν κατασκευαστή του αντικειμένου. </p>\r\n    <xmp>\r\n        // dhlwsi tis metavlitis troxos , I opoia einai anaphora pros to antikeimeno Circle \r\n        Circle troxos;\r\n        \r\n        //dimioyrgia antikeimenou tis klashw circle\r\n        troxos  = new Circle(20.0, 3.0, 4.0);  \r\n    </xmp>\r\n    <p>\r\n        Με το παραπάνω έχουν δοθεί τιμές <code>r1=20.0;</code>, <code>x1=3.0;</code> και <code>y1=4.0;</code> στα ορίσματα που έχει ο κατασκευαστής circle() της κλάσης και δημιουργήθηκε ένα αντικείμενο τροχός, το οποίο έχει ακτίνα 20.0 και συντεταγμένες κέντρου (3.0, 4.0) στο σύστημα αξόνων.  \r\n    </p>\r\n</div>\r\n\r\n<h4>Πως θα χρησιμοποιήσουμε μια κλάση που δημιουργήσαμε</h4>\r\n<div>\r\n    <p>Θα αποθηκευτεί η κλάση που φτιάχτηκε προηγουμένως με όνομα <code>Circle.java</code> και θα μεταγλωττιστεί. Έτσι θα δημιουργηθεί το αρχείο <file>Circle.class</file>. </p>\r\n    <xmp>\r\n        class Circle {\r\n\r\n            static double Pi = 3.14;\r\n            static int count = 0;\r\n            double radius;\r\n            double x;\r\n            double y;\r\n        \r\n            static int countCircle() {\r\n                return count;\r\n            }\r\n        \r\n            Circle(double r1, double x1, double y1) {\r\n                radius = r1;\r\n                x = x1;\r\n                y = y1;\r\n                ++count;\r\n            }\r\n        \r\n            double area() {\r\n                return Pi * radius * radius;\r\n            }\r\n        }\r\n    </xmp>\r\n    <p>Στη συνέχεια δημιουργείτε ένα πρόγραμμα <code>testCircle.java</code> όπου εκεί θα δημιουργηθούν αντικείμενα της κλάσης <code>Circle</code>.</p>\r\n    <xmp>\r\n        public class testCircle {\r\n\r\n            public static void main(String[] args) {\r\n        \r\n                System.out.println(\"Number of objects = \" + Circle.count);\r\n                \r\n                Circle troxos = new Circle(5.0, 1.0, 1.0);\r\n                System.out.println(\"Number of objects = \" + troxos.count);\r\n                \r\n                Circle roda = new Circle(4.0, 5.0, 5.0);\r\n                System.out.println(\"Number of objects = \" + roda.count);\r\n        \r\n                //ektypwsi tou emvadou kathe kyklou \r\n                System.out.println(\"Area of troxos = \" + troxos.area());\r\n                System.out.println(\"Area of roda = \" + roda.area());\r\n            }\r\n        }\r\n    </xmp>\r\n    <p>Στο παραπάνω παράδειγμα, η μεταβλητή <code>count</code>. της κλάσης <code>Circle</code> μετράει τον αριθμό των αντικειμένων που δημιουργούνται. </p>\r\n</div>\r\n\r\n<h3>Πολλαπλοί κατασκευαστές</h3>\r\n<div>\r\n    <p>Σε μια κλάση μπορεί να οριστούν περισσότεροι από ένας κατασκευαστές. Αυτό εξυπηρετεί την ανάγκη της κατασκευής αντικειμένων με διαφορετικά χαρακτηριστικά. Οι διαφορετικοί κατασκευαστές έχουν το ίδιο όνομα, όμως έχουν διαφορετική λίστα ορισμάτων.  </p>\r\n    <p>Στην κλάση <code>Circle</code> που έχουμε, ας κατασκευάσουμε έναν ακόμα κατασκευαστή, ο οποίος να έχει σταθερές συντεταγμένες και να μεταβάλλεται μόνο η ακτίνα του σχηματιζόμενου κύκλου. </p>\r\n    <xmp>\r\n        class Circle {\r\n\r\n            static double Pi = 3.14;\r\n            static int count = 0;\r\n            double radius;\r\n            double x;\r\n            double y;\r\n        \r\n            static int countCircle() {\r\n                return count;\r\n            }\r\n        \r\n            Circle(double r1, double x1, double y1) {\r\n                radius = r1;\r\n                x = x1;\r\n                y = y1;\r\n                ++count;\r\n            }\r\n        \r\n            Circle(double r2) {\r\n                x = 0.0;\r\n                y = 0.0;\r\n                radius = r2;\r\n                ++count;\r\n            }\r\n        \r\n            double area() {\r\n                return Pi * radius * radius;\r\n            }\r\n        }\r\n    </xmp>\r\n    <xmp>\r\n        public class testCircle {\r\n\r\n            public static void main(String[] args) {\r\n        \r\n                System.out.println(\"Number of objects = \" + Circle.count);\r\n        \r\n                Circle troxos = new Circle(5.0, 1.0, 1.0);\r\n                System.out.println(\"Number of objects = \" + troxos.count);\r\n        \r\n                Circle roda = new Circle(4.0);\r\n                System.out.println(\"Number of objects = \" + roda.count);\r\n        \r\n                //ektypwsi tou emvadou kathe kyklou \r\n                System.out.println(\"Area of troxos = \" + troxos.area());\r\n                System.out.println(\"Area of roda = \" + roda.area());\r\n            }\r\n        }\r\n    </xmp>\r\n    <p>Στο πρόγραμμα <code>testCircle.java</code> δημιουργήθηκε ένα αντικείμενο <code>troxos</code> με τον 1ο  κατασκευαστή <code>Circle</code> και το δεύτερο αντικείμενο <code>roda</code> με τον 2ο κατασκευαστή <code>Circle</code>. Οι κατασκευαστές 1 και 2 έχουν ίδιο όνομα αλλά διαφορετικά ορίσματα.</p>\r\n</div>\r\n\r\n<h3>Η αναφορά στα αντικείμενα</h3>\r\n<div>\r\n    <p>Όταν γίνεται αναφορά στα αντικείμενα, είναι πολύ σημαντικό να γνωρίζουμε πως αναφερόμαστε σ’ αυτά. Όταν εκχωρείτε ένα αντικείμενο σε μια μεταβλητή, η μεταβλητή δείχνει στο αντικείμενο, χωρίς να το περιλαμβάνει αυτό καθ’ αυτό.</p>\r\n    <p>Για παράδειγμα, δημιουργείται ένα νέο αντικείμενο – κύκλος, ο οποίος έχει ακτίνα 10.0 και συντεταγμένες 5.0 και 6.0. Το συγκεκριμένο αντικείμενο εκχωρείται στην μεταβλητή kyklos1 παρακάτω</p>\r\n    <xmp>\r\n        Circle kyklos1;  \r\n        kyklos1 = new Circle (10.0, 5.0, 6.0); \r\n        Circle kyklos2 = kyklos1; \r\n    </xmp>\r\n    <ul>\r\n        <li>Η δήλωση <code>Cyrcle kyklos1</code> δημιουργεί θέση στην μνήμη, η οποία προορίζεται να περιέχει πληροφορίες για την θέση που θα τοποθετηθεί το αντικείμενο.  </li>\r\n        <li>Η δήλωση <code>Kyklos1 = new Circle (10.0, 5.0, 6.0);</code> δημιουργεί ένα αντικείμενο το οποίο είναι τύπου <code>Circle</code> στη μνήμη, διαθέτοντας τα χαρακτηριστικά που έχουν αναφερθεί και ρυθμίζει την μεταβλητή <code>kyklos1</code> να δείχνει σε αυτό.</li>\r\n        <li>Η δήλωση <code>Circle kyklos2 = kyklos1;</code> δημιουργεί μια μεταβλητή η οποία δείχνει το ίδια αντικείμενο. </li>\r\n        <li>Αν αλλάξουμε τις παραμέτρους σε ένα αντικείμενο μέσω μιας μεταβλητής, τότε οι αλλαγές περνούν και στην άλλη.</li>\r\n    </ul>\r\n    <p>Παράδειγμα</p>\r\n    <xmp>\r\n        public class testCircle1 {\r\n\r\n            public static void main(String[] args) {\r\n        \r\n                Circle kyklos1, kyklos2;\r\n        \r\n                kyklos1 = new Circle(10.0, 5.0, 6.0);\r\n                kyklos2 = kyklos1;\r\n        \r\n                kyklos1.radius = 20.0;\r\n        \r\n                System.out.println(\"kyklos 1--> radius=\" + kyklos1.radius);\r\n                System.out.println(\"kyklos 2--> radius=\" + kyklos2.radius);\r\n                System.out.println(\"------------------------------\");\r\n        \r\n                kyklos2.radius = 50.0;\r\n        \r\n                System.out.println(\"kyklos 2--> radius=\" + kyklos2.radius);\r\n                System.out.println(\"kyklos 1--> radius=\" + kyklos1.radius);\r\n            }\r\n        }\r\n    </xmp>\r\n</div>\r\n\r\n\r\n<h3>Τι είναι τα πακέτα</h3>\r\n<div>\r\n    <p>Πακέτο (package), νοείται μια συλλογή από κλάσεις, οι οποίες χρησιμοποιούνται για να προσθέσουν δυνατότητες στην Java. Ο κώδικας που βρίσκεται μέσα στα πακέτα, μπορεί να χρησιμοποιείται σε διαφορετικά προγράμματα. Έτσι τελικά σαν πακέτο ορίζεται μια βιβλιοθήκη κώδικα. Κάθε κλάση στη Java περιέχετε μέσα σε ένα πακέτο. Οι κλάσεις που έχουν χρησιμοποιηθεί μέχρι στιγμής περιέχονται στο πακέτο με την ονομασία <code>java.lang</code>. Για παράδειγμα, καλώντας την δήλωση <code>System.out.prinln</code>, το <code>System</code> αναφέρετε στην κλάση <code>java.lang.System</code>, ενώ το <code>out</code> είναι ένα στατικό πεδίο από την κλάση <code>System</code>. Το πακέτο <code>java.lang</code>, είναι ειδικό πακέτο και εισάγεται αυτόματα σε κάθε νέο πρόγραμμα, χωρίς κάποια δήλωση. </p>\r\n    <p>Η χρησιμοποίηση μιας κλάσης ή μεθόδου, για ένα πακέτο γίνεται με δύο τρόπους \r\n        <ul>\r\n            <li>\r\n                Χρησιμοποιείται το πλήρες όνομα του πακέτου κατά τον ορισμό του αντικειμένου της κλάσης \r\n                <br/>\r\n                <code>Java.util.Date thisDate = new java.util.Date(); </code>\r\n                <br/>\r\n                Παραπάνω έγινε χρήση της Date, η οποία βρίσκεται στο πακέτο <code>util</code> και δημιουργήθηκε ένα νέο αντικείμενο αυτής της κλάσης το <code>thisDate</code>. \r\n            </li>\r\n            <li>\r\n                Γίνεται εισαγωγή της κλάσης στην αρχή του προγράμματος με την λέξη import και ύστερα γίνεται χρήση της κλάσης μέσα στο πρόγραμμα, γράφοντας μόνο το όνομά της.\r\n                <br/>\r\n                <xmp>\r\n                    import java.util.Date; \r\n                    Date thisDate = new Date();\r\n                </xmp>\r\n            </li>\r\n        </ul>\r\n    </p>\r\n    <p>Μερικές φορές, αντί να γίνει εισαγωγή μιας κλάσης είναι προτιμότερο να εισαχθεί ολόκληρο το πακέτο, κάνοντας χρήση ενός αστερίσκου <code>*</code>. Με αυτό τον τρόπο υπάρχει η δυνατότητα να γίνετε χρήση όλων των κλάσεων που βρίσκονται μέσα στο πακέτο. <code>import java.util.*;</code></p>\r\n</div>\r\n\r\n<h3>Τα τυπικά πακέτα της Java</h3>\r\n<div>\r\n    <p>Η γλώσσα της Java οφείλει την δυναμική της στα έτοιμα πακέτα τα οποία διαθέτει. Η βιβλιοθήκη των κλάσεων αναφέρεται ως <b>API</b> (Application Programming Interface), περιλαμβάνει πολλά πακέτα, τα οποία με κάθε νέα έκδοση της γλώσσας αυξάνονται. </p>\r\n    <p>Πακέτα της Java </p>\r\n    <table class=\"table table-striped\">\r\n        <tr>\r\n            <th>Πακέτο</th>\r\n            <th>Περιγραφή</th>\r\n        </tr>\r\n        <tr>\r\n            <td>Java.lang </td>\r\n            <td>Περιέχει βασικές κλάσεις της Java. Όλες οι κλάσεις του πακέτου είναι διαθέσιμες αυτόματα χωρίς αν χρειάζεται να γίνει η χρήση της λέξης <code>import</code>. Σημαντική κλάση του πακέτου αυτού είναι η <code>Math</code>.  </td>\r\n        </tr>\r\n        <tr>\r\n            <td>Java.io</td>\r\n            <td>Περιέχει κλάσεις που χρησιμοποιούνται για είσοδο ή έξοδο δεδομένων </td>\r\n        </tr>\r\n        <tr>\r\n            <td>Java.awt </td>\r\n            <td>Οι κλάσεις αυτού του πακέτου υποστηρίζουν το γραφικό περιβάλλον (GUI)  της java. Με την χρήση αυτών των πακέτων μπορούν να δημιουργηθούν μενού, παράθυρα, κουμπιά, πλαίσια διαλόγου.</td>\r\n        </tr>\r\n        <tr>\r\n            <td>Java.awt.event</td>\r\n            <td>Με αυτές τις κλάσεις γίνεται ο χειρισμός γεγονότων (event handling) </td>\r\n        </tr>\r\n        <tr>\r\n            <td>Java.applet </td>\r\n            <td>Κλάσεις για την συγγραφή προγραμμάτων τα οποία ενσωματώνονται σε σελίδες. Τα προγράμματα αυτά ονομάζονται applets </td>\r\n        </tr>\r\n        <tr>\r\n            <td>Java.util </td>\r\n            <td>Περιέχονται κλάσεις για εκτέλεση βασικών εργασιών σε δεδομένα, κλάσεις για τον χειρισμό ημερομηνιών, κλάσεις για τον χειρισμό αλφαριθμητικών.  </td>\r\n        </tr>\r\n        <tr>\r\n            <td>Java.awt.peer </td>\r\n            <td>Περιέχουν κλάσεις οι οποίες καθορίζουν το μέσο μετασχηματισμού των κλήσεων των μεθόδων του GUI της Java προς τις φυσικές τους υλοποιήσεις για μια συγκεκριμένη πλατφόρμα </td>\r\n        </tr>\r\n        <tr>\r\n            <td>Java.security </td>\r\n            <td>Περιέχει κλάσεις για την ασφάλεια στα προγράμματα της Java με μεθόδους κρυπτογραφίας. </td>\r\n        </tr>\r\n        <tr>\r\n            <td>Java.awt.image </td>\r\n            <td>Περιέχει κλάσεις για την επεξεργασία εικόνας </td>\r\n        </tr>\r\n        <tr>\r\n            <td>Java.net </td>\r\n            <td>Περιέχει κλάσεις για τις λειτουργίες δικτύου </td>\r\n        </tr>\r\n        <tr>\r\n            <td>Java.sql </td>\r\n            <td>Περιέχει κλάσεις οι οποίες υποστηρίζουν δημιουργία αυτοτελών τμημάτων κώδικα java, που μπορούν να ενσωματωθούν σε μια εφαρμογή </td>\r\n        </tr>\r\n        <tr>\r\n            <td>Java.rmi </td>\r\n            <td>Είναι πακέτα για την επίκληση απομακρυσμένων μεθόδων </td>\r\n        </tr>\r\n        <tr>\r\n            <td>Javax.sqing </td>\r\n            <td>Περιέχει κλάσεις και διασυνδέσεις οι οποίες χρησιμοποιούνται για την υλοποίηση συστατικών του νέου περιβάλλοντος επικοινωνίας με τον χρήστη (GUI), που αναφέρεται ως Swing </td>\r\n        </tr>\r\n    </table>\r\n</div>\r\n\r\n<h4>Πως μπορούμε να \"πακετάρουμε\" τις δικές μας κλάσεις</h4>\r\n<div>\r\n    <p>Κατά την δημιουργία νέων κλάσεων, είναι βολικό να τοποθετούνται όσες σχετίζονται μεταξύ τους σε πακέτα. Αν χρειάζεται οι μέθοδοι να είναι προσπελάσιμες έξω από τα πακέτα, θα πρέπει να δηλώνοντα βάζοντας μπροστά την λέξη <code>public</code>. Για να προστεθεί μια κλάση σε ένα πακέτο, πριν οριστεί, γράφουμε τη δήλωση </p>\r\n    <code>Package όνομα-πακέτου; </code>\r\n    <p>Για να τοποθετηθεί η κλάση Circle που έχουμε σε ένα πακέτο με όνομα Geometry, γράφουμε</p>\r\n    <xmp>\r\n        package Geometry; \r\n        public class Circle \r\n        { \r\n            (ΚΩΔΙΚΑΣ)\r\n        } \r\n    </xmp>\r\n    <p>\r\n        <a href=\"./learn.php?level=2&step=exercise#10\">Δες την λυμένη άσκηση</a>\r\n    </p>\r\n</div>\r\n\r\n<h3>Αντικειμενοστραφής προγραμματισμός</h3>\r\n<div>\r\n    <p>Η Java είναι αντικειμενοστραφής (Object oriented Programming) γλώσσα προγραμματισμού. Σε αυτό το είδος θεωρούνται τα στοιχεία του κάθε προγράμματος και ως αντικείμενα. Κάθε κλάση παρουσιάζει συγκεκριμένη εικόνα προς τα έξω. Η εικόνα αυτή δείχνει τις λειτουργείες τις οποίες επιτελεί μια κλάση και τα δεδομένα τα οποία χρησιμοποιεί. Όλα τα άλλα που συμβαίνουν μέσα σε κάθε κλάση, παραμένουν κρυφά. Την ιδέα του αντικειμενοστραφή προγραμματισμού, διέπουν τρεις αρχές\r\n        <ol>\r\n            <li>Η ενθυλάκωση (encapsulation)</li>\r\n            <li>Η κληρονομικότητα (inheritance)</li>\r\n            <li>Ο πολυμορφισμός (polymorphism)</li>\r\n        </ol>\r\n    </p>\r\n</div>\r\n\r\n<h3>Ενθυλάκωση – οι προσδιοριστές public, private και protected</h3>\r\n<div>\r\n    <p>\r\n        Η ενθυλάκωση δείχνει την εξωτερική όψη των αντικειμένων αποκρύπτοντας τις πολύπλοκες λογικές που υπάρχουν εντός αυτού. Με αυτόν τον τρόπο ο προγραμματιστής τροποποιεί ή βελτιώνει τους αλγόριθμους που υπάρχουν σε μια κλάση, χωρίς να ανησυχεί για τυχόν πρόκληση απρόβλεπτων προβλημάτων.  \r\n    </p>\r\n    <p>\r\n        Τα δεδομένα και οι μέθοδοι μιας κλάσης δηλώνονται ως <code>public</code>, <code>private</code>, <code>protected</code> ή χωρίς κανέναν από τους προσδιοριστές προσπέλασης (access modifiers). \r\n        <ul>\r\n            <li>\r\n                Μεταβλητές, μέθοδοι και κλάσεις που δηλώνονται ως <code>public</code> είναι προσπελάσιμες από οποιαδήποτε άλλη κλάση, όπου και αν αυτή βρίσκεται.  \r\n            </li>\r\n            <li>\r\n                Μεταβλητές και μέθοδοι  που χαρακτηρίζονται ως <code>private</code> μπορούν να  προσπελαστούν και να γίνει χρήση μόνο από το ίδιο το αντικείμενο. Δεν μπορούν να προσπελαστούν πουθενά έξω από αυτό.  \r\n            </li>\r\n            <li>\r\n                Μεταβλητές και μέθοδοι που χαρακτηρίζονται ως <code>protected</code> μπορούν να προσπελαστούν από όλες τις κλάσεις οι οποίες βρίσκονται στο ίδιο πακέτο, ή από υποκλάσεις  (subclasses) αυτής της κλάσης. \r\n            </li>\r\n            <li>\r\n                Αν δεν γίνει χρήση κανενός από τους ανωτέρω προσδιοριστές για μια μεταβλητή, μέθοδο ή κλάση, αυτή μπορεί να χρησιμοποιηθεί μόνο από τις κλάσεις οι οποίες βρίσκονται στο ίδιο πακέτο. \r\n            </li>\r\n        </ul>\r\n    </p>\r\n    <table class=\"table table-striped\">\r\n        <tr>\r\n            <th>Δυνατότητα προσπέλασης </th>\r\n            <th>Public</th>\r\n            <th>Protected</th>\r\n            <th>Χωρίς προσδιοριστή </th>\r\n            <th>Private</th>\r\n        </tr>\r\n        <tr>\r\n            <th>Από την ίδια κλάση </th>\r\n            <td>Ναι</td>\r\n            <td>Ναι</td>\r\n            <td>Ναι</td>\r\n            <td>Ναι</td>\r\n        </tr>\r\n        <tr>\r\n            <th>Από κλάσεις του ίδιου πακέτου </th>\r\n            <td>Ναι</td>\r\n            <td>Ναι</td>\r\n            <td>Ναι</td>\r\n            <td>Όχι</td>\r\n        </tr>\r\n        <tr>\r\n            <th>Από οποιαδήποτε κλάση εκτός του πακέτου στο οποίο ανήκει η κλάση </th>\r\n            <td>Ναι</td>\r\n            <td>Όχι</td>\r\n            <td>Όχι</td>\r\n            <td>Όχι</td>\r\n        </tr>\r\n        <tr>\r\n            <th>Από μια υποκλάση του ίδιου πακέτου </th>\r\n            <td>Ναι</td>\r\n            <td>Ναι</td>\r\n            <td>Ναι</td>\r\n            <td>Όχι</td>\r\n        </tr>\r\n        <tr>\r\n            <th>Από μια υποκλάση έξω από το πακέτο στο οποίο ανήκει η κλάση </th>\r\n            <td>Ναι</td>\r\n            <td>Ναι</td>\r\n            <td>Όχι</td>\r\n            <td>Όχι</td>\r\n        </tr>\r\n    </table>\r\n</div>\r\n\r\n<h3>Πολυμορφισμός</h3>\r\n<div>\r\n    <p>Ο πολυμορφισμός είναι ακόμα ένα χαρακτηριστικό του αντικειμενοστεφούς προγραμματισμού. Πολυμορφισμός υπάρχει όταν η ίδια η μέθοδος ή ο ίδιος τελεστής χρησιμοποιείται με διαφορετικούς τύπους δεδομένων.  </p>\r\n    <p>Χρήση του πολυμορφισμού γίνεται και στις κλάσεις που δημιουργεί ο χρήστης. Στο κεφάλαιο αυτό έγινε χρήση δύο τύπω κατασκευαστών της κλάσης Circle, από τους οποίους ο ένα είναι τρία ορίσματα ενώ ο άλλος ένα.</p>\r\n    <xmp>\r\n        class Circle {\r\n\r\n            static double Pi = 3.14;\r\n            static int count = 0;\r\n            double radius;\r\n            double x;\r\n            double y;\r\n        \r\n            static int countCircle() {\r\n                return count;\r\n            }\r\n        \r\n            Circle(double r1, double x1, double y1) {\r\n                radius = r1;\r\n                x = x1;\r\n                y = y1;\r\n                ++count;\r\n            }\r\n        \r\n            Circle(double r2) {\r\n                x = 0.0;\r\n                y = 0.0;\r\n                radius = r2;\r\n                ++count;\r\n            }\r\n        \r\n            double area() {\r\n                return Pi * radius * radius;\r\n            }\r\n        }\r\n    </xmp>\r\n    <p>Όταν έχουμε περισσότερους από έναν κατασκευαστές που έχουν το ίδιο όνομα αλλά έχουν διαφορετικά ιδιαίτερα ορίσματα, τότε έχουνε υπερφόρτωση κατασκευαστή (<b>constructor overloading</b>). Το όνομα του κατασκευαστή που συνδυάζεται με τον αριθμό, τον τύπο, και την σειρά των ορισμάτων αποτελούν την υπογραφή του (signature). Υπερφόρτωση ισχύει και στις μεθόδους (<b>method overloading</b>). Είναι εφικτό να δημιουργηθούν μέθοδοι με ίδιο όνομα και διαφορετικό ορισμό και ορίσματα και διαφορετική υπογραφή. </p>\r\n</div>\r\n\r\n<h3>Η κληρονομικότητα των κλάσεων</h3>\r\n<div>\r\n    <p>Με την χρήση της κληρονομικότητας , επαναχρησιμοποιείται κώδικας ο οποίος υπάρχει ήδη. Σύμφωνα με αυτή, ένα αντικείμενο έχει την δυνατότητα να κληρονομεί δεδομένα και μεθόδους ενός άλλου αντικειμένου, καθώς και να του επιφέρει τροποποιήσεις.  </p>\r\n    <p>Στην Java, όλες οι κλάσεις ακολουθούν μια ιεραρχία. Κάθε μια κλάση διαθέτει μια υπερκλάση (superclass) η οποία είναι ιεραρχικά πάνω από αυτή. Μπορεί να έχει όμως και υποκλάσεις (subclass), οι οποίες βρίσκονται σε κατώτερο επίπεδο ιεραρχίας.  </p>\r\n    <p>Έστω ότι φτιάχνεται μια κλάση αυτοκίνητο. Πρέπει να οριστούν μερικά χαρακτηριστικά του αυτοκινήτου όπως η εταιρία κατασκευής του, το μοντέλο, η ταχύτητα, η τιμή του κλπ. Η κλάση αυτή ορίζεται ως εξής</p>\r\n    <table class=\"table\">\r\n        <tr>\r\n            <th>Παρακάτω φτιάχνεται μια κλάση για αυτοκίνητα</th>\r\n            <th>Παρακάτω φτιάχνεται μια κλάση για μοτοσικλέτες</th>\r\n        </tr>\r\n        <tr>\r\n            <td>\r\n    <xmp>\r\n        class Car {\r\n\r\n            String manufacturer;\r\n            String model;\r\n        \r\n            int maximumSpeed;\r\n            int price;\r\n            int numDoors;\r\n            int numWheels = 4;\r\n        }\r\n    </xmp>\r\n            </td>\r\n            <td>\r\n    <xmp>\r\n        class motorCycle {\r\n\r\n            String manufacturer;\r\n            String model;\r\n        \r\n            int maximumSpeed;\r\n            int price;\r\n            int numWheels = 2;\r\n        }\r\n    </xmp>\r\n            </td>\r\n        </tr>\r\n    </table>\r\n    <p>Παραπάνω φαίνεται ότι οι δύο κλάσεις έχουν αρκετά κοινά  χαρακτηριστικά τα οποία μπορούμε να ορίσουμε σε μία υπερκλάση <code>motorVehicle</code>. Υστέρα θα ορίσουμε και δύο υποκλάσεις <code>Car</code> και <code>motorCycle</code>, οι οποίες θα κληρονομούν τα χαρακτηριστικά της υπερκλάσης.</p>\r\n    <xmp>\r\n        class motorVehicle {\r\n\r\n            String manufacturer;\r\n            String model;\r\n        \r\n            int maximumSpeed;\r\n            int price;\r\n            int numWheels;\r\n        }\r\n    </xmp>\r\n    <p>Για να δηλωθούν οι κλάσεις <code>Car</code> και <code>motorCycle</code> ως υποκλάση, γίνεται χρήση της λέξης <code>extends</code>.</p>\r\n    <table class=\"table\">\r\n        <tr>\r\n            <td>\r\n    <xmp>\r\n        class Car extends motorVehicle {\r\n            int numDoors;\r\n            int numWheels = 4;\r\n        }\r\n    </xmp>\r\n            </td>\r\n            <td>\r\n    <xmp>\r\n        class motorCycle extends motorVehicle {\r\n            int numWheels = 2;\r\n        }\r\n    </xmp>\r\n            </td>\r\n        </tr>\r\n    </table>\r\n    <p>Οι υποκλάσεις <code>Car</code> και <code>motorCycle</code> κληρονομούν τα χαρακτηριστικά της υπερκλάσης, εκτός από τα εσωτερικά χαρακτηριστικά που διαθέτουν. Η κληρονομικότητα μπορεί να επεκταθεί και σε περισσότερα επίπεδα (multilevel inheritance). Για παράδειγμα, αγροτικά αυτοκίνητα ορίζονται ως υποκλάση της <code>Car</code>, όπου έχει ως χαρακτηριστικό την καρότσα και τις θύρες.</p>\r\n    <p>\r\n        <a href=\"./learn.php?level=2&step=exercise#10\">Δες την λυμένη άσκηση</a>\r\n    </p>\r\n</div>\r\n\r\n<h3>Τελικές κλάσεις και μέθοδοι</h3>\r\n<div>\r\n    <p>Όταν χρειάζεται μια κλάση να μην δημιουργεί υποκλάσεις δηλώνεται ως τελική (final). Μια τέτοια κλάση δεν μπορεί να είναι υπερκλάση. Μέσω αυτής της δήλωσης ο μεταγλωττιστής δεν επιτρέπει δημιουργία υποκλάσεων της <code>MyClass</code>. </p>\r\n    <p><code>public final class MyClass</code></p>\r\n    <p>Ως τελική μπορεί αν δηλωθεί και μια μέθοδος. Mε αυτόν τον τρόπο η μέθοδος αυτή είναι αδύνατον να ακυρωθεί.</p>\r\n    <p><code>public final double area()</code></p>\r\n    <p>H final μπορεί να δηλωθεί και ως μεταβλητή, το οποίο την κάνει σταθερά. Αν τροποποιηθεί η <code>Pi</code> θα δημιουργηθεί σφάλμα (compile time error).</p>\r\n    <p><code>public final double Pi=3.14; </code></p>\r\n</div>\r\n\r\n<h3>Μέθοδοι και κλάσεις αφηρημένου τύπου</h3>\r\n<div>\r\n    <p>\r\n        Στην Java μπορεί να δηλωθεί μια μέθοδος ή μια κλάση ως αφηρημένη (abstract). Μια τέτοια μέθοδος, ορίζεται χωρίς να υλοποιείται. Το κύριο μέρος της κλάσης αυτής θα υλοποιηθεί σε υποκλάση της αρχικής κλάσης (αρχική είναι η κλάση στην οποία η μέθοδος ορίστηκε ως αφηρημένη). Η δήλωση της μεθόδου θα τελειώσει με <code>;</code>. \r\n    </p>\r\n    <p>\r\n        <code>public abstract getname(); </code> (getname είναι το όνομα που επιλέχθηκε για την μέθοδο). \r\n    </p>\r\n    <p>Για την δήλωση της κλάσης ως αφηρημένη γίνεται χρήση της <code>abstract</code>.  \r\n    </p>\r\n    <xmp>\r\n        public abstract class myclass {\r\n\r\n            private String astring;\r\n        \r\n            public void show() {\r\n                System.out.println(\"This is a\" + astring);\r\n            }\r\n            public abstract String getname();\r\n        }\r\n    </xmp>\r\n</div>\r\n\r\n<h3>Οι διασυνδέσεις</h3>\r\n<div>\r\n    <p>Η διασύνδεση, έχει πολλές ομοιότητες με μια συνηθισμένη κλάση, με την διαφορά, \r\n        ότι οι μέθοδοι που ορίζονται μέσα στην διασύνδεση δεν υλοποιούνται. \r\n        Αντί να γίνεται αυτό, η κάθε μέθοδος, υλοποιείται μέσα σε κάποια κλάση, \r\n        η οποία με την σειρά της καλεί την διασύνδεση. Η κλήση γίνεται χρησιμοποιώντας \r\n        την λέξη <code>implements</code> με το όνομα της διασύνδεσης. Η διασύνδεση είναι κατάλληλη \r\n        περιοχή για την δήλωση σταθερών. Άρα μια διασύνδεση είναι ένας χώρος στο οποίο \r\n        τοποθετούνται μια συλλογή από σταθερές και αφηρημένες μέθοδοι, οι οποίες μπορούν \r\n        να χρησιμοποιηθούν σε μια άλλη κλάση, γράφοντας σε αυτήν τον κώδικα για την \r\n        κάθε μέθοδο. Ο ορισμός μιας διασύνδεσης γίνεται όπως και στις κλάσης, όμως αντί \r\n        για class γίνεται χρήση του <code>interface</code>.</p>\r\n    <p>Δημιουργείται διασύνδεση με όνομα <code>LengthConversion</code> για μετατροπή μονάδων μήκους, όπου ορίζονται σταθερές και μέθοδοι χωρίς να μπει κώδικας σε αυτές. </p>\r\n    <xmp>\r\n        public interface LengthConversion {\r\n\r\n            double INCH_TO_CM = 2.54;\r\n            double FT_TO_CM = 30.5;\r\n            double YD_TO_M = 0.914;\r\n        \r\n            double inchTocm(double inches);\r\n            double ftTocm(double feet);\r\n            double ydTom(double meters);\r\n        }\r\n    </xmp>\r\n    <p>Στη συνέχεια δημιουργείται η κλάση <code>LengthMethods</code> που καλεί την διασύνδεση <code>LengthConversion</code> κάνοντας χρήση της λέξης <code>implements</code> και δημιουργώντας κώδικα για τις μεθόδους της.</p>\r\n    <xmp>\r\n        public class LengthMethods implements LengthConversion {\r\n\r\n            public double inchTocm(double inches) {\r\n                return inches * INCH_TO_CM;\r\n            }\r\n        \r\n            public double ftTocm(double feet) {\r\n                return feet * FT_TO_CM;\r\n            }\r\n        \r\n            public double ydTom(double yards) {\r\n                return yards * YD_TO_M;\r\n            }\r\n        }        \r\n    </xmp>\r\n    <p>Τέλος δημιουργείται η <code>showLengthConversion</code>, η οποία κάνει μετατροπή μήκους κάνοντας χρήση των μεθόδων της κλάσης <code>LengthMethods</code></p>\r\n    <xmp>    \r\n        public class showLengthConversion {\r\n\r\n            public static void main(String[] args) {\r\n\r\n                double vinch = 10.0;\r\n                double vcm = 0.0;\r\n\r\n                LengthMethods tL = new LengthMethods();\r\n                vcm = tL.inchTocm(vinch);\r\n\r\n                System.out.println(vinch + \"inches =\" + vcm + \"cm\");\r\n            }\r\n        }\r\n    </xmp>\r\n    <p>Όταν σε μια κλάση υλοποιούνται μέθοδοι διασύνδεσης, μπορούν να παραληφθούν μια ή περισσότερες από αυτές τις μεθόδους, όμως η κλάση πρέπει αν δηλωθεί ως αφηρημένη. </p>\r\n    <xmp>\r\n        public abstract class LengthClasses implements LengthConversion {\r\n\r\n            public double inchTocm(double inches) {\r\n                return inches * INCH_TO_CM;\r\n            }\r\n        \r\n            //den synperielifthisan oi ypollipes methodoi tou interface \r\n        }\r\n    </xmp>\r\n</div>', NULL, 5);
INSERT INTO `theory` (`id`, `title`, `description`, `downloadFile`, `level_id`) VALUES
(6, 'Εξαιρέσεις και ισχυρισμοί', '<h3>Τι είναι οι εξαιρέσεις</h3>\r\n<div>\r\n    <p>Όταν υπάρχει ένα πρόβλημα στην Java, το πρόγραμμα δημιουργεί μια εξαίρεση (exception). Για παράδειγμα όταν γράφουμε δεδομένα τα οποία υπερβαίνουν τα όρια ενός πίνακα. Έτσι, εξαίρεση (exception) έχουμε όταν το πρόγραμμα σε μία απροσδόκητη κατάσταση\r\n        δεν γνωρίζει τι πρέπει να κάνει. Η εξαίρεση έχει πλεονέκτημα στο ότι ο κώδικάς της είναι διαφορετικός από αυτόν που εκτελείτε όταν όλα γίνονται κανονικά. </p>\r\n    <p>Η εξαίρεση είναι αντικείμενο της υποκλάσης, η οποία βρίσκεται στην κλάση <code>java.lang.Throwable</code> και δημιουργείται όταν υπάρχει μια μη κανονική κατάσταση. </p>\r\n    <p>Η κλάση <code>Throwable</code> περιέχει δύο υποκλάσεις τις\r\n        <ul>\r\n            <li>\r\n                <code>Error</code>\r\n                <br/> Εξαιρέσεις οι οποίες ορίζονται από την <code>Error</code>, αντιπροσωπεύουν καταστάσεις στις οποίες δεν υπάρχει δυνατότητα επανόδου.\r\n            </li>\r\n            <li>\r\n                <code>Exception</code>\r\n                <br/> Στην εξαίρεση Exception υπάρχουν ειδικές εξαιρέσεις και εξαιρέσεις οι οποίες δημιουργούνται από σφάλματα όταν εκτελείται ένα πρόγραμμα (runtime exceptions).\r\n            </li>\r\n        </ul>\r\n    </p>\r\n    <p>\r\n        Μπορούν να δημιουργηθούν και ξεχωριστές εξαιρέσεις επεκτείνοντας την κλάση <code>java.lang.Exception</code>. Η Κλάση αυτή έχει δύο κατασκευαστές\r\n    </p>\r\n    <p><code>Exception()</code></p>\r\n    <p><code>Exception(String μήνυμα)</code></p>\r\n    <p>\r\n        Στον πρώτο κατασκευαστή δημιουργείται ένα αντικείμενο κλάσης exception, ενώ στον δεύτερο κατασκευαστή εμφανίζεται και ένα μήνυμα το οποίο έχει ορισθεί από πριν. Η πιο συνηθησμένη μέθοδος που υπάρχει στην κλάση Exception είναι η <code>public String getMessage()</code> \r\n        Η οποία επιστέφει μήνυμα της εξαίρεσης.\r\n    </p>\r\n    <p>Παράδειγμα δημιουργίας εξαίρεσης</p>\r\n    <xmp>\r\n        class MyException extends Exception{ \r\n\r\n        } \r\n    </xmp>\r\n    <xmp>\r\n        class MyException extends Exception{ \r\n\r\n            MyException (String message){        \r\n                super (message); \r\n            } \r\n        } \r\n    </xmp>\r\n    <p>Στην Java υπάρχει η δυνατότητα να δηλωθεί μια εξαίρεση όταν συμβούν κάποιες καταστάσεις. Αυτό μπορεί να συμβεί με την χρήση της λέξης <code>throws</code>, που χρησιμοποιείται στην γραμμή που δηλώνεται η μέθοδος.</p>\r\n    <xmp>\r\n        double myMethod() throws EOFException, InterruptedIOException \r\n        { \r\n            //kwdikas pou periexete sti method \r\n        } \r\n    </xmp>\r\n    <p>Η εξαίρεση δύναται να παραχθεί από το πρόγραμμα με χρήση της <code>throw</code>. Για παράδειγμα</p>\r\n    <p><code>throw new IOException(\"File not Found\"); </code></p>\r\n</div>\r\n\r\n<h3>Τύποι εξαιρέσεων</h3>\r\n<div>\r\n    <p>Υπάρχουν πολλοί τύποι εξαιρέσεων οι οποίες προκύπτουν από τον τύπο <code>Throwable</code>. Μερικές από αυτές είναι </p>\r\n    <xmp>\r\n        Throwable \r\n            Error \r\n                LinkageError \r\n                    IncompatibleClassChangeError \r\n                InstantiationError \r\n                VirtualMachineError \r\n                    InternalError \r\n                    OutOfMemoryError \r\n                    StackOverflowError \r\n                Exception \r\n                IllegalAccessException \r\n                IOException \r\n                    EOFException \r\n                    FileNotFoundException \r\n                    InterruptedIOException \r\n                    MalformedURLException \r\n                RuntimeError \r\n                    ArithmeticException \r\n                    ArrayStoreException \r\n                    ClassCastException \r\n                    EmptyStackException \r\n                    IllegalArgumentException \r\n                        IllegalThreadStateException \r\n                        NumberFormatException \r\n                    IndexOutOfBoundsException \r\n                        ArrayIndexOutOfBoundsException \r\n                        StringIndexOutOfBoundsException \r\n                    NegativeArraySizeException \r\n                    NullPointerException \r\n                    SecurityException \r\n    </xmp>\r\n    <p>Στον παρακάτω πίνακα φαίνονται αναλυτικότερα κάποιες εξαιρέσεις από τις οποίες οι περισσότερες είναι υποκλάσεις της <code>RuntimeException</code> και ανήκουν σε πακέτα <code>java.lang</code> και <code>java.util</code></p>\r\n    <table class=\"table table-striped\">\r\n        <tr>\r\n            <th>Όνομα κλάσης</th>\r\n            <th>Κατάσταση που αντιστοιχεί </th>\r\n        </tr>\r\n        <tr>\r\n            <td><code>ArithmeticException </code></td>\r\n            <td>Μια αδύνατη αριθμητική κατάσταση π.χ. διαίρεση με το μηδέν </td>\r\n        </tr>\r\n        <tr>\r\n            <td><code>ArrayStoreException </code></td>\r\n            <td>Μη επιτρεπτή προσπάθεια αποθήκευσης ενός δεδομένου σε έναν πίνακα </td>\r\n        </tr>\r\n        <tr>\r\n            <td><code>EmptyStactException</code></td>\r\n            <td>Μια μη επιτρεπτή πράξη σε ένα άδειο αντικείμενο στοίβας π.χ. άντληση (pop) ενός στοιχείου από αυτό </td>\r\n        </tr>\r\n        <tr>\r\n            <td><code>FileNotFoundException </code></td>\r\n            <td>Προσπάθεια προσπέλασης ενός μη υπάρχοντος αρχείου </td>\r\n        </tr>\r\n        <tr>\r\n            <td><code>IllegalArgumentException</code></td>\r\n            <td>Πέρασμα μη επιτρεπτού ορίσματος σε μια μέθοδο </td>\r\n        </tr>\r\n        <tr>\r\n            <td><code>IndexOfBoundsException</code></td>\r\n            <td>Προσπάθεια χρήσης δείκτη έξω από τα όρια ενός αντικειμένου </td>\r\n        </tr>\r\n        <tr>\r\n            <td><code>IOException</code></td>\r\n            <td>Προκαλείται από αποτυχημένη προσπάθεια εισόδου / εξόδου, όπως αδυναμία ανάγνωσης δεδομένων από ένα αρχείο </td>\r\n        </tr>\r\n        <tr>\r\n            <td><code>NegativeArraySizeException</code></td>\r\n            <td>Προσπάθεια ορίσματος ενός πίνακα με αρνητικό μέγεθος </td>\r\n        </tr>\r\n        <tr>\r\n            <td><code>NumberFormatException</code></td>\r\n            <td>Προκαλείται σε μια αποτυχημένη μετατροπή αλφαριθμητικού δεδομένου σε αριθμητικό </td>\r\n        </tr>\r\n        <tr>\r\n            <td><code>OutOfMemoryException</code></td>\r\n            <td>Προκαλείται όταν δεν υπάρχει αρκετός χώρος για την καταχώρηση ενός νέου αντικειμένου </td>\r\n        </tr>\r\n        <tr>\r\n            <td><code>StringIndexOutOfBounds</code></td>\r\n            <td>Προκαλείται όταν ένα πρόγραμμα προσπαθεί να προσπελάσει μια μη υπάρχουσα θέση χαρακτήρα ενός αλφαριθμητικού </td>\r\n        </tr>\r\n    </table>\r\n</div>\r\n\r\n<h3>Χειρισμός εξαιρέσεων</h3>\r\n<div>\r\n    <p>Ο χειρισμός των εξαιρέσεων (exceptional handling), βασίζεται στο ότι όταν κάποια μέθοδος εντοπίσει ένα σφάλμα, παράγει μια εξαίρεση. Όταν παράγεται αυτή η εξαίρεση, δεν αντιμετωπίζεται πάντα αυτόματα.  Όταν κώδικας αντιμετωπίζει μια εξαίρεση, τότε η εξαίρεση θα συλληφθεί (catch) και θα υποστεί διαχείριση (handle). Οι προγραμματιστές που ασχολούνται με τις εξαιρέσεις χρησιμοποιούν τρία κομμάτια κώδικα, το <code>try</code>, το <code>catch</code> και το <code>finally</code>.  \r\n        Όταν χρειάζεται να γίνει σύλληψη μιας εξαίρεσης, δημιουργείται κώδικας ο οποίος δημιουργεί μια εξαίρεση. Το try το ακολουθεί το catch. Το κομμάτι αυτό περιέχει κώδικα για χειρισμό της εξαίρεσης. </p>\r\n    <xmp>\r\n        try \r\n        { \r\n            //kwdikas \r\n        } \r\n        catch(τύπος εξαίρεσης e) \r\n        { \r\n            //kwdikas xeirismou \r\n        } \r\n    </xmp>\r\n    <p>Όταν μια από τις εντολές η οποία βρίσκεται μέσα σε ένα <code>try</code> δημιουργεί μια εξαίρεση, η ροή του προγράμματος διακόπτεται και το σύστημα αναζητάει το κομμάτι κώδικα που χειρίζεται αυτή την εξαίρεση μέσα στο <code>catch</code>. Μόλις περαιωθεί ο κώδικας που υπάρχει στο try/catch, το πρόγραμμα συνεχίζεται εκτός αν ο κώδικας του try/catch τερματίζει με κάποια δήλωσή του το πρόγραμμα. Ένα <code>try</code> μπορεί να δημιουργήσει πολλές εξαιρέσεις και υπάρχει η δυνατότητα για κάθε εξαίρεση που δημιούργησε το <code>try</code> να υπάρχει και ένα <code>catch</code> που να χειρίζεται την εξαίρεση. Έτσι σε αυτές τις περιπτώσεις σημαντικό ρόλο παίζει η σειρά που τοποθετούνται τα <code>catch</code> στον κώδικα.</p>\r\n    <xmp>\r\n        try \r\n        { \r\n            //kwdikas \r\n        } \r\n        catch(Exception ex) \r\n        { \r\n            //kwdikas xeirismou \r\n        } \r\n        catch(Arithmetic exception ex) \r\n        { \r\n            //kwdikas xeirismou \r\n        } \r\n    </xmp>\r\n    <p>Το <code>catch</code> που αντιστοιχεί στην εξαίρεση τύπου <code>ArithmeticException</code> δεν θα εκτελεστεί, διότι ακόμα και αν συμβεί αυτό, εκτελείται ο κώδικας της <code>Exception</code> η οποία είναι υπερκλάση της <code>ArithmeticException</code>. Έτσι όταν υπάρχουν πολλά <code>catch</code> τα οποία αναφέρονται σε εξαιρέσεις που ανήκουν στην ίδια ιεραρχία, πρέπει να γίνεται προσεκτική τοποθέτηση των μπλοκ και στην αρχή να υπάρχουν εκείνα με τις χαμηλότερες σε ιεραρχία υποκλάσεις και στη συνέχεια εκείνα με τις υψηλότερες.  </p>\r\n</div>\r\n\r\n<h3>Δημιουργία των δικών μας εξαιρέσεων</h3>\r\n<div>\r\n    <p>Οι εξαιρέσεις είναι κλάσεις, όπως όλες στην ιεραρχία της java. Μερικές φορές γεννάται η ανάγκη δημιουργίας εξαιρέσεων οι οποίες αντιμετωπίζουν ειδικούς τύπους σφαλμάτων που υπάρχει περίπτωση να εμφανιστούν σε ένα πρόγραμμα. Η εξαίρεση που θα δημιουργηθεί πρέπει να κληρονομεί από κάποια άλλη κλάση ιεραρχία στην java. Η νέα εξαίρεση είναι παρεμφερής με εκείνη από την οποία κληρονομεί. Αν αυτό δεν γίνεται, θεωρείται ότι η εξαίρεση που δημιουργήθηκε κληρονομεί από την Exception η οποία βρίσκεται στην κορυφή της ιεραρχίας.</p>\r\n    <p>\r\n        <a href=\"./learn.php?level=15&step=exercise#34\">Δες την λυμένη άσκηση</a>\r\n    </p>\r\n</div>\r\n\r\n<h3>Το τμήμα finally</h3>\r\n<div>\r\n    <p>Το <code>finally</code> είναι προαιρετικό και τοποθετείται μετά από μια ομάδα με try/catch. </p>\r\n    <xmp>\r\n        try{ \r\n            //kwdikas \r\n        }  \r\n        catch(exception1 e){ \r\n            //kwdikas \r\n        } \r\n        catch(exception2 e){ \r\n            //kwdikas \r\n        } \r\n        finally{ \r\n            //kwdikas \r\n        } \r\n    </xmp>\r\n    <p>O κώδικας της <code>finally</code>, εκτελείται πάντα μετά από τα try/catch, πάντα χωρίς να επηρεάζεται από το αν θα δημιουργηθούν εξαιρέσεις. Ο μόνος λόγος ώστε να μην εκτελεστεί ο κώδικας του <code>finally</code> είναι να υπάρχει η δήλωση <code>System.exit(0)</code>, όπου τερματίζει το πρόγραμμα.  </p>\r\n    <xmp>\r\n        public class showFinally {\r\n\r\n            public static void main(String args[]) {\r\n        \r\n                char[] arr = new char[10];\r\n        \r\n                try {\r\n                    arr[9] = \'A\';\r\n                    System.out.println(\"A B C\");\r\n                } catch (RuntimeException e) {\r\n                    System.out.println(\"D E F\");\r\n                    throw e;\r\n                } finally {\r\n                    System.out.println(\"G H I\");\r\n                }\r\n            }\r\n        }\r\n    </xmp>\r\n    <p>Το οποίο τυπώνει</p> \r\n    <xmp>\r\n        ABC \r\n        GHI \r\n    </xmp>\r\n</div>\r\n\r\n<h3>Ισχυρισμοί</h3>\r\n<div>\r\n    <p>Ένα ακόμα χαρακτηριστικό που υπάρχει στην Java είναι οι ισχυρισμοί. Οι ισχυρισμοί μπορούν να χρησιμοποιηθούν ως ένα εργαλείο ελέγχου του κώδικα. Οι ισχυρισμοί προέρχονται από μια μέθοδο αντιμετώπισης σφαλμάτων του κώδικα που λέγετε «Σχεδίαση κατά σύμβαση» (Design by Contract - DBC) ο οποίος χρησιμοποιείται σε διάφορες γλώσσες. Η μέθοδος αυτή, για να ελέγξει ότι ένα  κομμάτι κώδικα συμπεριφέρεται σωστά θέτει: \r\n        <ul>\r\n            <li>\r\n                Προϋποθέσεις (Preconditions) οι οποίες αφορούν περιορισμούς που πρέπει να ισχύουν ώστε να δουλεύει σωστά ο κώδικας. Παράδειγμα: δεν επιτρέπετε να καλείτε μια μέθοδος push() ώστε να προστεθεί ένα στοιχείο σε μια στοίβα που είναι γεμάτη.  \r\n            </li>\r\n            <li>\r\n                Όρους εκ των υστέρων (Postconditions) που αφορούν διάφορες καταστάσεις οι οποίες ισχύουν αφού γίνει μια ενέργεια. Παράδειγμα: μια στοίβα δεν είναι άδεια, όταν έχει τοποθετηθεί ένα στοιχείο σε αυτή και το στοιχείο αυτό είναι στην κορυφή της.  \r\n            </li>\r\n            <li>\r\n                Σταθερές καταστάσεις (Invariants) εκφράζουν ιδιότητες τις οποίες πρέπει να έχει ο κώδικας σε «σταθερές» περιόδους. Κυρίως αφορούν χρονικές στιγμές πριν την κλήση μια μεθόδου, μετά την επιστροφή από αυτή ή όταν ολοκληρωθεί ένας κατασκευαστής.   \r\n            </li>\r\n        </ul>\r\n        Στην Java δεν γίνεται ακριβώς το Design By Contract, διότι υπήρχε φόβος ότι θα δημιουργηθεί ασυμβατότητα μεταξύ νέων και παλαιότερων βιβλιοθηκών. Έτσι σε αυτή  τη γλώσσα προγραμματισμού εισάγονται λογικοί (Boolean) έλεγχοι στον κώδικα μέσω ισχυρισμών ώστε να φανεί η ορθότητα του κάθε προγράμματος. Οι ισχυρισμοί ενεργοποιούνται μόνο από τον προγραμματιστή για να γίνει έλεγχος στον πρόγραμμα.\r\n    </p>\r\n    <p>\r\n        Για να υλοποιηθεί ένας ισχυρισμός γίνετε χρήση της δεσμευμένης λέξης <code>assert</code> την οποία ακολουθάει μια λογική πρόταση όπου ο προγραμματιστής ξέρει ότι ισχύει. Αν κατά την εκτέλεση του κώδικα, ο ισχυρισμός ισχύει και η λογική έκφραση είναι αληθής (true) δεν γίνεται κάποια ενέργεια.  Αν η λογική έκφραση γίνει false, η λέξη <code>assert</code> δημιουργεί μια εξαίρεση, την <code>java.lang.AssertionError</code> που εκφράζεται χωρίς να έχει σχόλια.   \r\n    </p>\r\n    <p>Σύνταξη της assert \r\n        <ol>\r\n            <li><code>Assert λογική_έκφραση; </code></li>\r\n            <li><code>Assert λογική_έκφραση:έκφραση2; </code></li>\r\n        </ol>\r\n        Στην δεύτερη περίπτωση αν η έκφραση που ακολουθεί την <code>assert</code> γίνει false, τότε η έκφραση2 λαμβάνεται ως μήνυμα σφάλματος και τοποθετείται στον κατασκευαστή της <code>AssertionError</code>. \r\n    </p>\r\n    <xmp>\r\n        public class showAssertions1 { \r\n\r\n            public static void main(String[] args) { \r\n        \r\n                boolean enable = false; \r\n                assert enable = true; \r\n\r\n                System.out.println(\"Oi isxirismoi einai \" +  (enable ? \"energoi\" : \"anenergoi\"));       \r\n            }            \r\n        } \r\n    </xmp>\r\n    <p>Για να  μεταγλωττιστεί το πρόγραμμα πληκτρολογούμε <code>Javac -source 1.6 showAssertions1.java</code> </p>\r\n    <p>Για να μεταγλωττιστεί ο κώδικας ο οποίος περιέχει ισχυρισμούς γίνεται χρήση του διακόπτη -source 1.6.</p>\r\n    <p>Μόλις εκτελεστεί το πρόγραμμα, για να ενεργοποιηθούν οι ισχυρισμοί γίνεται χρήση του διακόπτη -ea (enable assertions) <code>Java -ea showAssertions</code> </p>\r\n    <p>Αν δεν γίνει αυτό, οι ισχυρισμοί θα μείνουν ανενεργοί παρότι θα δημιουργηθούν από τον μεταγλωττιστή.</p>\r\n    <p>\r\n        <a href=\"./learn.php?level=15&step=exercise#35\">Δες την λυμένη άσκηση</a>\r\n    </p>\r\n</div>', NULL, 15),
(13, 'Νήματα', '<h3>Τι είναι τα νήματα</h3>\r\n<div>\r\n    <p>Παλαιότερα οι υπολογιστές έκαναν μια ενέργεια μόνο κάθε χρονική στιγμή, εκτελώντας προγράμματα συριακά και το κάθε πρόγραμμα που έτρεχε είχε τον έλεγχο του μηχανήματος. Μόλις αναπτύχθηκαν λειτουργικά συστήματα καταμερισμού χρόνου (time sharing) δημιουργήθηκε η δυνατότητα στον υπολογιστή να μοιράζει τον χρόνο που λειτουργεί σε πολλούς χρήστες και να εκτελεί ταυτόχρονα, διαφορετικά προγράμματα. Αυτό γινόταν με την διαίρεση του χρόνου λειτουργίας του συστήματος και την παραχώρηση ενός χρονικού παραθύρου στο πρόγραμμα κάθε χρήστη.  Επόμενα βήματα έδιναν την δυνατότητα σε ένα χρήστη να τρέχει πολλά προγράμματα ταυτόχρονα στον ίδιο υπολογιστή με το κατάλληλο λογισμικό το οποίο ονομάζεται και πολυδιεργασία (multitasking), όπου κάθε πρόγραμμα, ανεξαρτήτως των άλλων προγραμμάτων που τρέχουν ταυτόχρονα, ακολουθεί την δικιά του πορεία εκτέλεσης.  Μερικές  φορές, δημιουργείται  η ανάγκη ένα πρόγραμμα να εκτελεί πολλές διεργασίες ταυτόχρονα. Η δυνατότητα ένα πρόγραμμα να εκτελεί ταυτόχρονα διάφορες διεργασίες, ονομάζεται <code>threads</code>.</p>\r\n    <p>Η έννοια του νήματος, είναι μια ξεχωριστή ροή κώδικα που λαμβάνει χώρα, μαζί με άλλες ροές και επεξεργασίας που κάνει ο υπολογιστής. Κάθε applet η εφαρμογή java έχει τουλάχιστον ένα νήμα.</p>\r\n    <p>Στην java δημιουργούνται νήματα με δύο τρόπους \r\n        <ol>\r\n            <li>Δημιουργώντας μια κλάση και μετατρέποντάς την σε νήμα. Αυτό γίνεται μέσω της εφαρμογής της διασύνδεσης Runnable. Αυτή η διασύνδεση, ορίζει την μέθοδο <code>run()</code> για όλους τους τύπους των νημάτων. Η <code>run()</code> είναι void και δεν περιέχει όρισμα. </li>\r\n            <li>Γράφοντας ξεχωριστή κλάση η οποία προέρχεται από την κλάση <code>thred</code> (<code>java.lang.Thread</code>) της Java. H κλάση <code>thread</code> εφαρμόζει την διασύνδεση της <code>Runnable</code> και έτσι περιέχει την μέθοδο <code>run()</code>, την οποία ο χρήστης πρέπει να παρακάμπτει για να εκτελεί ότι χρειάζεται. </li>\r\n        </ol>\r\n    </p>\r\n    <p>Για να γίνει η εκτέλεση ενός νήματος πρέπει να κληθεί η μέθοδος <code>start()</code>. Με αυτό τον τρόπο το νήμα καταχωρίζεται στον χρονοπρογραμματιστή νήματος (thread scheduler). Ο χρονοπρογραμματιστής καθορίζει το πιο από τα νήμα θα εκτελεστούν. Όταν υπάρχει η ανάγκη καθυστέρησης μια διεργασίας, γίνεται χρήση της μεθόδου <code>sleep(n)</code>. Ο αριθμός <code>n</code> είναι ακέραιος τύπου <code>long</code> και καθορίζεται σε χιλιοστά του δευτερολέπτου (milliseconds). Η μέθοδο <code>sleep</code>, μπορεί αν δημιουργήσει την εξαίρεση <code>InterruptedException</code> και έτσι πρέπει να τοποθετείται σε try/catch. </p>\r\n    <xmp>\r\n        try{ \r\n            Sleep(n);    \r\n        }           \r\n        catch(InterruptedException e) \r\n        { \r\n        \r\n        } \r\n    </xmp>\r\n    <p>Το κάθε νήμα μπορεί αν βρεθεί σε διάφορες καταστάσεις.\r\n        <ul>\r\n            <li>Αρχικά όταν δημιουργείται βρίσκεται σε κατάσταση γέννησης (born state)</li>\r\n            <li> Όταν κληθεί η μέθοδος start() το νήμα βρίσκεται ε κατάσταση ετοιμότητας (ready state)</li>\r\n            <li>Όταν τερματιστεί η μέθοδος run() το νήμα τίθεται σε κατάσταση τερματισμού (dead state), από όπου δεν  μπορεί να τεθεί ξανά σε ετοιμότητα.</li>\r\n        </ul>\r\n    </p>\r\n</div>\r\n\r\n<h3>Το νήμα δαίμων</h3>\r\n<div>\r\n    <p>\r\n        Το νήμα δαίμων (daemon thread), είναι νήμα που εκτελείται προς όφελος άλλων νημάτων. Τα νήματα τα οποία ονομάζονται περισυλλογής απορριμμάτων (garbage collector) είναι είδος νήματος δαίμονα.  \r\n    </p>\r\n    <p>\r\n        Κάνοντας χρήση της μεθόδου <code>setDaemon()</code> χρησιμοποιώντας το όρισμα true χαρακτηρίζεται ένα νήμα, «νήμα δαίμονα». \r\n    </p>\r\n    <p><code>MyThread.setDaemon(true)</code></p>    \r\n    <p> Αν το νήμα είναι όντος δαίμονα, μπορεί να οριστεί κάνοντας χρήση της μεθόδου <code>isDaemon</code>.</p>\r\n    <p><code>MyThread.isDaemon()</code></p>    \r\n</div>\r\n\r\n<h3>Δημιουργία νήματος με την κλάση Thread</h3>\r\n<div>\r\n    <p>\r\n        Ένας εκ των δύο τρόπων με τους οποίους δημιουργούνται τα νήματα είναι χρήση της κλάσης <code>Thread</code>.  Έτσι δημιουργείται μια καινούργια κλάση που επεκτείνει την <code>thread</code> και έτσι παρακάμπτεται η μέθοδος <code>run()</code>, βάζοντας κώδικα που χεριάζετε να εκτελέσει η κλάση.  \r\n    </p>\r\n    <p>\r\n        Εντός της εφαρμογής, γίνεται δημιουργία ενός αντικειμένου της κλάσης του νήματος και στη συνέχεια γίνεται εκκίνηση αυτού. Έτσι υπάρχουν δύο ταυτόχρονες διεργασίες-νήματα: μια είναι η ίδια η εφαρμογή και η δεύτερη η διεργασία του νήματος που δημιουργήθηκε. Μπορεί να επιτευχθεί η επικοινωνία του νήματος με την εφαρμογή, αν δοθεί στην κλάση του νήματος δυνατότητα να κάνει χρήση δεδομένων και μεθόδους της εφαρμογής. \r\n    </p>\r\n    <p>\r\n        Αρχή εκτέλεσης ενός νήματος γίνεται με την μέθοδο <code>start()</code>. Σε κάθε νήμα πρέπει αν υπάρχει η μέθοδος <code>run()</code> η οποία δηλώνεται ως <code>public</code>, δεν παίρνει ορίσματα και δεν επιστρέφει κάποια τιμή.  \r\n    </p>\r\n    <p>\r\n        <a href=\"./learn.php?level=16&step=exercise#36\">Δες την λυμένη άσκηση</a>\r\n    </p>\r\n</div>', NULL, 16);

-- --------------------------------------------------------

--
-- Table structure for table `user`
--

DROP TABLE IF EXISTS `user`;
CREATE TABLE IF NOT EXISTS `user` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `Fname` varchar(30) COLLATE utf8_bin NOT NULL,
  `Lname` varchar(30) COLLATE utf8_bin NOT NULL,
  `email` varchar(100) COLLATE utf8_bin NOT NULL,
  `password` varchar(50) COLLATE utf8_bin NOT NULL,
  `role_id` int(11) NOT NULL,
  PRIMARY KEY (`id`),
  KEY `role_id` (`role_id`)
) ENGINE=MyISAM AUTO_INCREMENT=9 DEFAULT CHARSET=utf8 COLLATE=utf8_bin;

--
-- Dumping data for table `user`
--

INSERT INTO `user` (`id`, `Fname`, `Lname`, `email`, `password`, `role_id`) VALUES
(1, 'Kostas', 'Andronis', 'kostas@gmail.com', '111', 2),
(2, 'Konstantinos', 'Andronis', 'konstantinos@gmail.com', '111', 1),
(6, 'TestUser', 'TestUser', 'user@test.gr', 'User1234', 2),
(8, 'TestAdmin', 'TestAdmin', 'admin@test.gr', 'Admin1234', 1);

-- --------------------------------------------------------

--
-- Table structure for table `useranswer`
--

DROP TABLE IF EXISTS `useranswer`;
CREATE TABLE IF NOT EXISTS `useranswer` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `questionnaire_id` int(11) NOT NULL,
  `timestamp` datetime NOT NULL,
  `user_id` int(11) NOT NULL,
  `level_id` int(11) NOT NULL,
  `question_id` int(11) NOT NULL,
  `answer_id` int(11) DEFAULT NULL,
  `answer_text` varchar(500) COLLATE utf8_bin DEFAULT NULL,
  PRIMARY KEY (`id`),
  KEY `user_id` (`user_id`),
  KEY `answer_id` (`answer_id`),
  KEY `question_id` (`question_id`),
  KEY `FK_Level` (`level_id`)
) ENGINE=MyISAM AUTO_INCREMENT=23 DEFAULT CHARSET=utf8 COLLATE=utf8_bin;

--
-- Dumping data for table `useranswer`
--

INSERT INTO `useranswer` (`id`, `questionnaire_id`, `timestamp`, `user_id`, `level_id`, `question_id`, `answer_id`, `answer_text`) VALUES
(1, 1, '2020-06-06 17:09:59', 1, 1, 1, 3, NULL),
(2, 1, '2020-06-06 17:09:59', 1, 1, 2, 5, NULL),
(3, 1, '2020-06-06 17:09:59', 1, 1, 3, NULL, NULL),
(4, 1, '2020-06-06 17:09:59', 1, 1, 15, 33, NULL),
(5, 1, '2020-06-06 17:09:59', 1, 1, 15, 34, NULL),
(6, 2, '2020-06-06 17:10:23', 1, 2, 10, 23, NULL),
(7, 2, '2020-06-06 17:10:23', 1, 2, 16, NULL, NULL),
(8, 2, '2020-06-06 17:10:23', 1, 2, 17, 39, NULL),
(9, 2, '2020-06-06 17:10:23', 1, 2, 18, NULL, 'asdasf'),
(10, 2, '2020-06-06 17:10:23', 1, 2, 19, NULL, NULL),
(11, 2, '2020-06-06 17:10:23', 1, 2, 20, NULL, NULL),
(12, 2, '2020-06-06 17:10:23', 1, 2, 21, NULL, NULL),
(13, 2, '2020-06-06 17:10:23', 1, 2, 22, NULL, NULL),
(14, 3, '2020-06-06 17:18:24', 1, 2, 10, 23, NULL),
(15, 3, '2020-06-06 17:18:24', 1, 2, 16, NULL, '????????????'),
(16, 3, '2020-06-06 17:18:24', 1, 2, 17, 38, NULL),
(17, 3, '2020-06-06 17:18:24', 1, 2, 17, 40, NULL),
(18, 3, '2020-06-06 17:18:24', 1, 2, 18, NULL, '101'),
(19, 3, '2020-06-06 17:18:24', 1, 2, 19, 43, NULL),
(20, 3, '2020-06-06 17:18:24', 1, 2, 20, 45, NULL),
(21, 3, '2020-06-06 17:18:24', 1, 2, 21, 47, NULL),
(22, 3, '2020-06-06 17:18:24', 1, 2, 22, 50, NULL);
COMMIT;

/*!40101 SET CHARACTER_SET_CLIENT=@OLD_CHARACTER_SET_CLIENT */;
/*!40101 SET CHARACTER_SET_RESULTS=@OLD_CHARACTER_SET_RESULTS */;
/*!40101 SET COLLATION_CONNECTION=@OLD_COLLATION_CONNECTION */;
